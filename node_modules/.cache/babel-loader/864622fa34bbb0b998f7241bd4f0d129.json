{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Classes as CoreClasses, Portal, Utils as CoreUtils, mergeRefs } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport { Popover2 } from \"./popover2\";\nimport { Tooltip2Context, Tooltip2Provider } from \"./tooltip2Context\";\nexport var ContextMenu2 = React.forwardRef(function (props, userRef) {\n  var _a;\n\n  var _b;\n\n  var className = props.className,\n      children = props.children,\n      content = props.content,\n      _c = props.disabled,\n      disabled = _c === void 0 ? false : _c,\n      onContextMenu = props.onContextMenu,\n      popoverProps = props.popoverProps,\n      _d = props.tagName,\n      tagName = _d === void 0 ? \"div\" : _d,\n      restProps = __rest(props, [\"className\", \"children\", \"content\", \"disabled\", \"onContextMenu\", \"popoverProps\", \"tagName\"]); // ancestor Tooltip2Context state doesn't affect us since we don't care about parent ContextMenu2s, we only want to\n  // force disable parent Tooltip2s in certain cases through dispatching actions\n  // N.B. any calls to this dispatch function will be no-ops if there is no Tooltip2Provider ancestor of this component\n\n\n  var _e = React.useContext(Tooltip2Context),\n      tooltipCtxDispatch = _e[1]; // click target offset relative to the viewport (e.clientX/clientY), since the target will be rendered in a Portal\n\n\n  var _f = React.useState(undefined),\n      targetOffset = _f[0],\n      setTargetOffset = _f[1]; // hold a reference to the click mouse event to pass to content/child render functions\n\n\n  var _g = React.useState(),\n      mouseEvent = _g[0],\n      setMouseEvent = _g[1];\n\n  var _h = React.useState(false),\n      isOpen = _h[0],\n      setIsOpen = _h[1]; // we need a ref on the child element (or the wrapper we generate) to check for dark theme\n\n\n  var childRef = React.useRef(null); // If disabled prop is changed, we don't want our old context menu to stick around.\n  // If it has just been enabled (disabled = false), then the menu ought to be opened by\n  // a new mouse event. Users should not be updating this prop in the onContextMenu callback\n  // for this component (that will lead to unpredictable behavior).\n\n  React.useEffect(function () {\n    setIsOpen(false);\n    tooltipCtxDispatch({\n      type: \"RESET_DISABLED_STATE\"\n    });\n  }, [disabled]);\n  var cancelContextMenu = React.useCallback(function (e) {\n    return e.preventDefault();\n  }, []);\n  var handlePopoverInteraction = React.useCallback(function (nextOpenState) {\n    if (!nextOpenState) {\n      setIsOpen(false);\n      setMouseEvent(undefined);\n      tooltipCtxDispatch({\n        type: \"RESET_DISABLED_STATE\"\n      });\n    }\n  }, []); // Popover2 should attach its ref to the virtual target we render inside a Portal, not the \"inline\" child target\n\n  var renderTarget = React.useCallback(function (_a) {\n    var ref = _a.ref;\n    return React.createElement(Portal, null, React.createElement(\"div\", {\n      className: Classes.CONTEXT_MENU2_VIRTUAL_TARGET,\n      style: targetOffset,\n      ref: ref\n    }));\n  }, [targetOffset]); // if the menu was just opened, we should check for dark theme (but don't do this on every render)\n\n  var isDarkTheme = React.useMemo(function () {\n    return CoreUtils.isDarkTheme(childRef.current);\n  }, [childRef, isOpen]); // only render the popover if there is content in the context menu;\n  // this avoid doing unnecessary rendering & computation\n\n  var contentProps = {\n    isOpen: isOpen,\n    mouseEvent: mouseEvent,\n    targetOffset: targetOffset\n  };\n  var menu = disabled ? undefined : CoreUtils.isFunction(content) ? content(contentProps) : content;\n  var maybePopover = menu === undefined ? undefined : React.createElement(Popover2, __assign({}, popoverProps, {\n    content: // this prevents right-clicking inside our context menu\n    React.createElement(\"div\", {\n      onContextMenu: cancelContextMenu\n    }, menu),\n    enforceFocus: false,\n    // Generate key based on offset so that a new Popover instance is created\n    // when offset changes, to force recomputing position.\n    key: getPopoverKey(targetOffset),\n    hasBackdrop: true,\n    backdropProps: {\n      className: Classes.CONTEXT_MENU2_BACKDROP\n    },\n    isOpen: isOpen,\n    minimal: true,\n    onInteraction: handlePopoverInteraction,\n    popoverClassName: classNames(Classes.CONTEXT_MENU2_POPOVER2, popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.popoverClassName, (_a = {}, _a[CoreClasses.DARK] = isDarkTheme, _a)),\n    placement: \"right-start\",\n    positioningStrategy: \"fixed\",\n    rootBoundary: \"viewport\",\n    renderTarget: renderTarget,\n    transitionDuration: (_b = popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.transitionDuration) !== null && _b !== void 0 ? _b : 100\n  }));\n  var handleContextMenu = React.useCallback(function (e) {\n    // support nested menus (inner menu target would have called preventDefault())\n    if (e.defaultPrevented) {\n      return;\n    } // If disabled, we should avoid this extra work. Otherwise: if using the child function API,\n    // we need to make sure contentProps is up to date for correctness, so we handle the event regardless\n    // of whether the consumer returned an undefined menu.\n\n\n    var shouldHandleEvent = !disabled && (CoreUtils.isFunction(children) || maybePopover !== undefined);\n\n    if (shouldHandleEvent) {\n      e.preventDefault();\n      e.persist();\n      setMouseEvent(e);\n      setTargetOffset({\n        left: e.clientX,\n        top: e.clientY\n      });\n      setIsOpen(true);\n      tooltipCtxDispatch({\n        type: \"FORCE_DISABLED_STATE\"\n      });\n    }\n\n    onContextMenu === null || onContextMenu === void 0 ? void 0 : onContextMenu(e);\n  }, [onContextMenu, disabled]);\n  var containerClassName = classNames(className, Classes.CONTEXT_MENU2);\n  var child = CoreUtils.isFunction(children) ? children({\n    className: containerClassName,\n    contentProps: contentProps,\n    onContextMenu: handleContextMenu,\n    popover: maybePopover,\n    ref: childRef\n  }) : React.createElement(React.Fragment, null, maybePopover, React.createElement(tagName, __assign({\n    className: containerClassName,\n    onContextMenu: handleContextMenu,\n    ref: mergeRefs(childRef, userRef)\n  }, restProps), children)); // force descendant Tooltip2s to be disabled when this context menu is open\n\n  return React.createElement(Tooltip2Provider, {\n    forceDisable: isOpen\n  }, child);\n});\nContextMenu2.displayName = \"Blueprint.ContextMenu2\";\n\nfunction getPopoverKey(targetOffset) {\n  return targetOffset === undefined ? \"default\" : targetOffset.left + \"x\" + targetOffset.top;\n}","map":{"version":3,"sources":["../../src/contextMenu2.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Classes as CoreClasses, Portal, Utils as CoreUtils, mergeRefs, } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport { Popover2 } from \"./popover2\";\nimport { Tooltip2Context, Tooltip2Provider } from \"./tooltip2Context\";\nexport var ContextMenu2 = React.forwardRef(function (props, userRef) {\n    var _a;\n    var _b;\n    var className = props.className, children = props.children, content = props.content, _c = props.disabled, disabled = _c === void 0 ? false : _c, onContextMenu = props.onContextMenu, popoverProps = props.popoverProps, _d = props.tagName, tagName = _d === void 0 ? \"div\" : _d, restProps = __rest(props, [\"className\", \"children\", \"content\", \"disabled\", \"onContextMenu\", \"popoverProps\", \"tagName\"]);\n    // ancestor Tooltip2Context state doesn't affect us since we don't care about parent ContextMenu2s, we only want to\n    // force disable parent Tooltip2s in certain cases through dispatching actions\n    // N.B. any calls to this dispatch function will be no-ops if there is no Tooltip2Provider ancestor of this component\n    var _e = React.useContext(Tooltip2Context), tooltipCtxDispatch = _e[1];\n    // click target offset relative to the viewport (e.clientX/clientY), since the target will be rendered in a Portal\n    var _f = React.useState(undefined), targetOffset = _f[0], setTargetOffset = _f[1];\n    // hold a reference to the click mouse event to pass to content/child render functions\n    var _g = React.useState(), mouseEvent = _g[0], setMouseEvent = _g[1];\n    var _h = React.useState(false), isOpen = _h[0], setIsOpen = _h[1];\n    // we need a ref on the child element (or the wrapper we generate) to check for dark theme\n    var childRef = React.useRef(null);\n    // If disabled prop is changed, we don't want our old context menu to stick around.\n    // If it has just been enabled (disabled = false), then the menu ought to be opened by\n    // a new mouse event. Users should not be updating this prop in the onContextMenu callback\n    // for this component (that will lead to unpredictable behavior).\n    React.useEffect(function () {\n        setIsOpen(false);\n        tooltipCtxDispatch({ type: \"RESET_DISABLED_STATE\" });\n    }, [disabled]);\n    var cancelContextMenu = React.useCallback(function (e) { return e.preventDefault(); }, []);\n    var handlePopoverInteraction = React.useCallback(function (nextOpenState) {\n        if (!nextOpenState) {\n            setIsOpen(false);\n            setMouseEvent(undefined);\n            tooltipCtxDispatch({ type: \"RESET_DISABLED_STATE\" });\n        }\n    }, []);\n    // Popover2 should attach its ref to the virtual target we render inside a Portal, not the \"inline\" child target\n    var renderTarget = React.useCallback(function (_a) {\n        var ref = _a.ref;\n        return (React.createElement(Portal, null,\n            React.createElement(\"div\", { className: Classes.CONTEXT_MENU2_VIRTUAL_TARGET, style: targetOffset, ref: ref })));\n    }, [targetOffset]);\n    // if the menu was just opened, we should check for dark theme (but don't do this on every render)\n    var isDarkTheme = React.useMemo(function () { return CoreUtils.isDarkTheme(childRef.current); }, [childRef, isOpen]);\n    // only render the popover if there is content in the context menu;\n    // this avoid doing unnecessary rendering & computation\n    var contentProps = { isOpen: isOpen, mouseEvent: mouseEvent, targetOffset: targetOffset };\n    var menu = disabled ? undefined : CoreUtils.isFunction(content) ? content(contentProps) : content;\n    var maybePopover = menu === undefined ? undefined : (React.createElement(Popover2, __assign({}, popoverProps, { content: \n        // this prevents right-clicking inside our context menu\n        React.createElement(\"div\", { onContextMenu: cancelContextMenu }, menu), enforceFocus: false, \n        // Generate key based on offset so that a new Popover instance is created\n        // when offset changes, to force recomputing position.\n        key: getPopoverKey(targetOffset), hasBackdrop: true, backdropProps: { className: Classes.CONTEXT_MENU2_BACKDROP }, isOpen: isOpen, minimal: true, onInteraction: handlePopoverInteraction, popoverClassName: classNames(Classes.CONTEXT_MENU2_POPOVER2, popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.popoverClassName, (_a = {},\n            _a[CoreClasses.DARK] = isDarkTheme,\n            _a)), placement: \"right-start\", positioningStrategy: \"fixed\", rootBoundary: \"viewport\", renderTarget: renderTarget, transitionDuration: (_b = popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.transitionDuration) !== null && _b !== void 0 ? _b : 100 })));\n    var handleContextMenu = React.useCallback(function (e) {\n        // support nested menus (inner menu target would have called preventDefault())\n        if (e.defaultPrevented) {\n            return;\n        }\n        // If disabled, we should avoid this extra work. Otherwise: if using the child function API,\n        // we need to make sure contentProps is up to date for correctness, so we handle the event regardless\n        // of whether the consumer returned an undefined menu.\n        var shouldHandleEvent = !disabled && (CoreUtils.isFunction(children) || maybePopover !== undefined);\n        if (shouldHandleEvent) {\n            e.preventDefault();\n            e.persist();\n            setMouseEvent(e);\n            setTargetOffset({ left: e.clientX, top: e.clientY });\n            setIsOpen(true);\n            tooltipCtxDispatch({ type: \"FORCE_DISABLED_STATE\" });\n        }\n        onContextMenu === null || onContextMenu === void 0 ? void 0 : onContextMenu(e);\n    }, [onContextMenu, disabled]);\n    var containerClassName = classNames(className, Classes.CONTEXT_MENU2);\n    var child = CoreUtils.isFunction(children) ? (children({\n        className: containerClassName,\n        contentProps: contentProps,\n        onContextMenu: handleContextMenu,\n        popover: maybePopover,\n        ref: childRef,\n    })) : (React.createElement(React.Fragment, null,\n        maybePopover,\n        React.createElement(tagName, __assign({ className: containerClassName, onContextMenu: handleContextMenu, ref: mergeRefs(childRef, userRef) }, restProps), children)));\n    // force descendant Tooltip2s to be disabled when this context menu is open\n    return React.createElement(Tooltip2Provider, { forceDisable: isOpen }, child);\n});\nContextMenu2.displayName = \"Blueprint.ContextMenu2\";\nfunction getPopoverKey(targetOffset) {\n    return targetOffset === undefined ? \"default\" : targetOffset.left + \"x\" + targetOffset.top;\n}\n//# sourceMappingURL=contextMenu2.js.map"]},"metadata":{},"sourceType":"module"}