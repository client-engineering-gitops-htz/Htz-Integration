{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __rest } from \"tslib\";\nimport * as React from \"react\";\nimport { AbstractComponent2, DISPLAYNAME_PREFIX, Keys, Menu, Utils } from \"@blueprintjs/core\";\nimport { executeItemsEqual, getActiveItem, getCreateNewItem, isCreateNewItem, renderFilteredItems } from \"../../common\";\n\nvar QueryList =\n/** @class */\nfunction (_super) {\n  __extends(QueryList, _super);\n\n  function QueryList(props, context) {\n    var _a, _b;\n\n    var _this = _super.call(this, props, context) || this;\n\n    _this.refHandlers = {\n      itemsParent: function (ref) {\n        return _this.itemsParentRef = ref;\n      }\n    };\n    /**\n     * Flag indicating that we should check whether selected item is in viewport\n     * after rendering, typically because of keyboard change. Set to `true` when\n     * manipulating state in a way that may cause active item to scroll away.\n     */\n\n    _this.shouldCheckActiveItemInViewport = false;\n    /**\n     * The item that we expect to be the next selected active item (based on click\n     * or key interactions). When scrollToActiveItem = false, used to detect if\n     * an unexpected external change to the active item has been made.\n     */\n\n    _this.expectedNextActiveItem = null;\n    /**\n     * Flag which is set to true while in between an ENTER \"keydown\" event and its\n     * corresponding \"keyup\" event.\n     *\n     * When entering text via an IME (https://en.wikipedia.org/wiki/Input_method),\n     * the ENTER key is pressed to confirm the character(s) to be input from a list\n     * of options. The operating system intercepts the ENTER \"keydown\" event and\n     * prevents it from propagating to the application, but \"keyup\" is still\n     * fired, triggering a spurious event which this component does not expect.\n     *\n     * To work around this quirk, we keep track of \"real\" key presses by setting\n     * this flag in handleKeyDown.\n     */\n\n    _this.isEnterKeyPressed = false;\n    /** default `itemListRenderer` implementation */\n\n    _this.renderItemList = function (listProps) {\n      var _a = _this.props,\n          initialContent = _a.initialContent,\n          noResults = _a.noResults; // omit noResults if createNewItemFromQuery and createNewItemRenderer are both supplied, and query is not empty\n\n      var createItemView = listProps.renderCreateItem();\n      var maybeNoResults = createItemView != null ? null : noResults;\n      var menuContent = renderFilteredItems(listProps, maybeNoResults, initialContent);\n\n      if (menuContent == null && createItemView == null) {\n        return null;\n      }\n\n      var createFirst = _this.isCreateItemFirst();\n\n      return React.createElement(Menu, {\n        ulRef: listProps.itemsParentRef\n      }, createFirst && createItemView, menuContent, !createFirst && createItemView);\n    };\n    /** wrapper around `itemRenderer` to inject props */\n\n\n    _this.renderItem = function (item, index) {\n      if (_this.props.disabled !== true) {\n        var _a = _this.state,\n            activeItem = _a.activeItem,\n            query = _a.query;\n        var matchesPredicate = _this.state.filteredItems.indexOf(item) >= 0;\n        var modifiers = {\n          active: executeItemsEqual(_this.props.itemsEqual, getActiveItem(activeItem), item),\n          disabled: isItemDisabled(item, index, _this.props.itemDisabled),\n          matchesPredicate: matchesPredicate\n        };\n        return _this.props.itemRenderer(item, {\n          handleClick: function (e) {\n            return _this.handleItemSelect(item, e);\n          },\n          index: index,\n          modifiers: modifiers,\n          query: query\n        });\n      }\n\n      return null;\n    };\n\n    _this.renderCreateItemMenuItem = function () {\n      if (_this.isCreateItemRendered()) {\n        var _a = _this.state,\n            activeItem = _a.activeItem,\n            query = _a.query;\n        var trimmedQuery_1 = query.trim();\n\n        var handleClick = function (evt) {\n          _this.handleItemCreate(trimmedQuery_1, evt);\n        };\n\n        var isActive = isCreateNewItem(activeItem);\n        return _this.props.createNewItemRenderer(trimmedQuery_1, isActive, handleClick);\n      }\n\n      return null;\n    };\n\n    _this.handleItemCreate = function (query, evt) {\n      var _a, _b, _c, _d; // we keep a cached createNewItem in state, but might as well recompute\n      // the result just to be sure it's perfectly in sync with the query.\n\n\n      var item = (_b = (_a = _this.props).createNewItemFromQuery) === null || _b === void 0 ? void 0 : _b.call(_a, query);\n\n      if (item != null) {\n        (_d = (_c = _this.props).onItemSelect) === null || _d === void 0 ? void 0 : _d.call(_c, item, evt);\n\n        _this.maybeResetQuery();\n      }\n    };\n\n    _this.handleItemSelect = function (item, event) {\n      var _a, _b;\n\n      _this.setActiveItem(item);\n\n      (_b = (_a = _this.props).onItemSelect) === null || _b === void 0 ? void 0 : _b.call(_a, item, event);\n\n      _this.maybeResetQuery();\n    };\n\n    _this.handlePaste = function (queries) {\n      var _a = _this.props,\n          createNewItemFromQuery = _a.createNewItemFromQuery,\n          onItemsPaste = _a.onItemsPaste;\n      var nextActiveItem;\n      var nextQueries = []; // Find an exising itemÂ that exactly matches each pasted value, or\n      // create a new item if possible. Ignore unmatched values if creating\n      // items is disabled.\n\n      var pastedItemsToEmit = [];\n\n      for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {\n        var query = queries_1[_i];\n        var equalItem = getMatchingItem(query, _this.props);\n\n        if (equalItem !== undefined) {\n          nextActiveItem = equalItem;\n          pastedItemsToEmit.push(equalItem);\n        } else if (_this.canCreateItems()) {\n          var newItem = createNewItemFromQuery === null || createNewItemFromQuery === void 0 ? void 0 : createNewItemFromQuery(query);\n\n          if (newItem !== undefined) {\n            pastedItemsToEmit.push(newItem);\n          }\n        } else {\n          nextQueries.push(query);\n        }\n      } // UX nicety: combine all unmatched queries into a single\n      // comma-separated query in the input, so we don't lose any information.\n      // And don't reset the active item; we'll do that ourselves below.\n\n\n      _this.setQuery(nextQueries.join(\", \"), false); // UX nicety: update the active item if we matched with at least one\n      // existing item.\n\n\n      if (nextActiveItem !== undefined) {\n        _this.setActiveItem(nextActiveItem);\n      }\n\n      onItemsPaste === null || onItemsPaste === void 0 ? void 0 : onItemsPaste(pastedItemsToEmit);\n    };\n\n    _this.handleKeyDown = function (event) {\n      var _a, _b; // eslint-disable-next-line deprecation/deprecation\n\n\n      var keyCode = event.keyCode;\n\n      if (keyCode === Keys.ARROW_UP || keyCode === Keys.ARROW_DOWN) {\n        event.preventDefault();\n\n        var nextActiveItem = _this.getNextActiveItem(keyCode === Keys.ARROW_UP ? -1 : 1);\n\n        if (nextActiveItem != null) {\n          _this.setActiveItem(nextActiveItem);\n        }\n      } else if (keyCode === Keys.ENTER) {\n        _this.isEnterKeyPressed = true;\n      }\n\n      (_b = (_a = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    };\n\n    _this.handleKeyUp = function (event) {\n      var onKeyUp = _this.props.onKeyUp;\n      var activeItem = _this.state.activeItem; // eslint-disable-next-line deprecation/deprecation\n\n      if (event.keyCode === Keys.ENTER && _this.isEnterKeyPressed) {\n        // We handle ENTER in keyup here to play nice with the Button component's keyboard\n        // clicking. Button is commonly used as the only child of Select. If we were to\n        // instead process ENTER on keydown, then Button would click itself on keyup and\n        // the Select popover would re-open.\n        event.preventDefault();\n\n        if (activeItem == null || isCreateNewItem(activeItem)) {\n          _this.handleItemCreate(_this.state.query, event);\n        } else {\n          _this.handleItemSelect(activeItem, event);\n        }\n\n        _this.isEnterKeyPressed = false;\n      }\n\n      onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(event);\n    };\n\n    _this.handleInputQueryChange = function (event) {\n      var _a, _b;\n\n      var query = event == null ? \"\" : event.target.value;\n\n      _this.setQuery(query);\n\n      (_b = (_a = _this.props).onQueryChange) === null || _b === void 0 ? void 0 : _b.call(_a, query, event);\n    };\n\n    var _c = props.query,\n        query = _c === void 0 ? \"\" : _c;\n    var createNewItem = (_a = props.createNewItemFromQuery) === null || _a === void 0 ? void 0 : _a.call(props, query);\n    var filteredItems = getFilteredItems(query, props);\n    _this.state = {\n      activeItem: props.activeItem !== undefined ? props.activeItem : (_b = props.initialActiveItem) !== null && _b !== void 0 ? _b : getFirstEnabledItem(filteredItems, props.itemDisabled),\n      createNewItem: createNewItem,\n      filteredItems: filteredItems,\n      query: query\n    };\n    return _this;\n  }\n\n  QueryList.ofType = function () {\n    return QueryList;\n  };\n\n  QueryList.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        items = _a.items,\n        renderer = _a.renderer,\n        _b = _a.itemListRenderer,\n        itemListRenderer = _b === void 0 ? this.renderItemList : _b;\n\n    var _c = this.state,\n        createNewItem = _c.createNewItem,\n        spreadableState = __rest(_c, [\"createNewItem\"]);\n\n    return renderer(__assign(__assign({}, spreadableState), {\n      className: className,\n      handleItemSelect: this.handleItemSelect,\n      handleKeyDown: this.handleKeyDown,\n      handleKeyUp: this.handleKeyUp,\n      handlePaste: this.handlePaste,\n      handleQueryChange: this.handleInputQueryChange,\n      itemList: itemListRenderer(__assign(__assign({}, spreadableState), {\n        items: items,\n        itemsParentRef: this.refHandlers.itemsParent,\n        renderCreateItem: this.renderCreateItemMenuItem,\n        renderItem: this.renderItem\n      }))\n    }));\n  };\n\n  QueryList.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n\n    if (this.props.activeItem !== undefined && this.props.activeItem !== this.state.activeItem) {\n      this.shouldCheckActiveItemInViewport = true;\n      this.setState({\n        activeItem: this.props.activeItem\n      });\n    }\n\n    if (this.props.query != null && this.props.query !== prevProps.query) {\n      // new query\n      this.setQuery(this.props.query, this.props.resetOnQuery, this.props);\n    } else if ( // same query (or uncontrolled query), but items in the list changed\n    !Utils.shallowCompareKeys(this.props, prevProps, {\n      include: [\"items\", \"itemListPredicate\", \"itemPredicate\"]\n    })) {\n      this.setQuery(this.state.query);\n    }\n\n    if (this.shouldCheckActiveItemInViewport) {\n      // update scroll position immediately before repaint so DOM is accurate\n      // (latest filteredItems) and to avoid flicker.\n      this.requestAnimationFrame(function () {\n        return _this.scrollActiveItemIntoView();\n      }); // reset the flag\n\n      this.shouldCheckActiveItemInViewport = false;\n    }\n  };\n\n  QueryList.prototype.scrollActiveItemIntoView = function () {\n    var scrollToActiveItem = this.props.scrollToActiveItem !== false;\n    var externalChangeToActiveItem = !executeItemsEqual(this.props.itemsEqual, getActiveItem(this.expectedNextActiveItem), getActiveItem(this.props.activeItem));\n    this.expectedNextActiveItem = null;\n\n    if (!scrollToActiveItem && externalChangeToActiveItem) {\n      return;\n    }\n\n    var activeElement = this.getActiveElement();\n\n    if (this.itemsParentRef != null && activeElement != null) {\n      var activeTop = activeElement.offsetTop,\n          activeHeight = activeElement.offsetHeight;\n      var _a = this.itemsParentRef,\n          parentOffsetTop = _a.offsetTop,\n          parentScrollTop = _a.scrollTop,\n          parentHeight = _a.clientHeight; // compute padding on parent element to ensure we always leave space\n\n      var _b = this.getItemsParentPadding(),\n          paddingTop = _b.paddingTop,\n          paddingBottom = _b.paddingBottom; // compute the two edges of the active item for comparison, including parent padding\n\n\n      var activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;\n      var activeTopEdge = activeTop - paddingTop - parentOffsetTop;\n\n      if (activeBottomEdge >= parentScrollTop + parentHeight) {\n        // offscreen bottom: align bottom of item with bottom of viewport\n        this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;\n      } else if (activeTopEdge <= parentScrollTop) {\n        // offscreen top: align top of item with top of viewport\n        this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;\n      }\n    }\n  };\n\n  QueryList.prototype.setQuery = function (query, resetActiveItem, props) {\n    var _a;\n\n    if (resetActiveItem === void 0) {\n      resetActiveItem = this.props.resetOnQuery;\n    }\n\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var createNewItemFromQuery = props.createNewItemFromQuery;\n    this.shouldCheckActiveItemInViewport = true;\n    var hasQueryChanged = query !== this.state.query;\n\n    if (hasQueryChanged) {\n      (_a = props.onQueryChange) === null || _a === void 0 ? void 0 : _a.call(props, query);\n    } // Leading and trailing whitespace can be confusing to display, so we remove it when passing it\n    // to functions dealing with data, like createNewItemFromQuery. But we need the unaltered user-typed\n    // query to remain in state to be able to render controlled text inputs properly.\n\n\n    var trimmedQuery = query.trim();\n    var filteredItems = getFilteredItems(trimmedQuery, props);\n    var createNewItem = createNewItemFromQuery != null && trimmedQuery !== \"\" ? createNewItemFromQuery(trimmedQuery) : undefined;\n    this.setState({\n      createNewItem: createNewItem,\n      filteredItems: filteredItems,\n      query: query\n    }); // always reset active item if it's now filtered or disabled\n\n    var activeIndex = this.getActiveIndex(filteredItems);\n    var shouldUpdateActiveItem = resetActiveItem || activeIndex < 0 || isItemDisabled(getActiveItem(this.state.activeItem), activeIndex, props.itemDisabled);\n\n    if (shouldUpdateActiveItem) {\n      // if the `createNewItem` is first, that should be the first active item.\n      if (this.isCreateItemRendered() && this.isCreateItemFirst()) {\n        this.setActiveItem(getCreateNewItem());\n      } else {\n        this.setActiveItem(getFirstEnabledItem(filteredItems, props.itemDisabled));\n      }\n    }\n  };\n\n  QueryList.prototype.setActiveItem = function (activeItem) {\n    var _a, _b, _c, _d;\n\n    this.expectedNextActiveItem = activeItem;\n\n    if (this.props.activeItem === undefined) {\n      // indicate that the active item may need to be scrolled into view after update.\n      this.shouldCheckActiveItemInViewport = true;\n      this.setState({\n        activeItem: activeItem\n      });\n    }\n\n    if (isCreateNewItem(activeItem)) {\n      (_b = (_a = this.props).onActiveItemChange) === null || _b === void 0 ? void 0 : _b.call(_a, null, true);\n    } else {\n      (_d = (_c = this.props).onActiveItemChange) === null || _d === void 0 ? void 0 : _d.call(_c, activeItem, false);\n    }\n  };\n\n  QueryList.prototype.getActiveElement = function () {\n    var activeItem = this.state.activeItem;\n\n    if (this.itemsParentRef != null) {\n      if (isCreateNewItem(activeItem)) {\n        var index = this.isCreateItemFirst() ? 0 : this.state.filteredItems.length;\n        return this.itemsParentRef.children.item(index);\n      } else {\n        var activeIndex = this.getActiveIndex();\n        return this.itemsParentRef.children.item(activeIndex);\n      }\n    }\n\n    return undefined;\n  };\n\n  QueryList.prototype.getActiveIndex = function (items) {\n    if (items === void 0) {\n      items = this.state.filteredItems;\n    }\n\n    var activeItem = this.state.activeItem;\n\n    if (activeItem == null || isCreateNewItem(activeItem)) {\n      return -1;\n    } // NOTE: this operation is O(n) so it should be avoided in render(). safe for events though.\n\n\n    for (var i = 0; i < items.length; ++i) {\n      if (executeItemsEqual(this.props.itemsEqual, items[i], activeItem)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  QueryList.prototype.getItemsParentPadding = function () {\n    // assert ref exists because it was checked before calling\n    var _a = getComputedStyle(this.itemsParentRef),\n        paddingTop = _a.paddingTop,\n        paddingBottom = _a.paddingBottom;\n\n    return {\n      paddingBottom: pxToNumber(paddingBottom),\n      paddingTop: pxToNumber(paddingTop)\n    };\n  };\n  /**\n   * Get the next enabled item, moving in the given direction from the start\n   * index. A `null` return value means no suitable item was found.\n   *\n   * @param direction amount to move in each iteration, typically +/-1\n   * @param startIndex item to start iteration\n   */\n\n\n  QueryList.prototype.getNextActiveItem = function (direction, startIndex) {\n    if (startIndex === void 0) {\n      startIndex = this.getActiveIndex();\n    }\n\n    if (this.isCreateItemRendered()) {\n      var reachedCreate = startIndex === 0 && direction === -1 || startIndex === this.state.filteredItems.length - 1 && direction === 1;\n\n      if (reachedCreate) {\n        return getCreateNewItem();\n      }\n    }\n\n    return getFirstEnabledItem(this.state.filteredItems, this.props.itemDisabled, direction, startIndex);\n  };\n\n  QueryList.prototype.isCreateItemRendered = function () {\n    return this.canCreateItems() && this.state.query !== \"\" && // this check is unfortunately O(N) on the number of items, but\n    // alas, hiding the \"Create Item\" option when it exactly matches an\n    // existing item is much clearer.\n    !this.wouldCreatedItemMatchSomeExistingItem();\n  };\n\n  QueryList.prototype.isCreateItemFirst = function () {\n    return this.props.createNewItemPosition === \"first\";\n  };\n\n  QueryList.prototype.canCreateItems = function () {\n    return this.props.createNewItemFromQuery != null && this.props.createNewItemRenderer != null;\n  };\n\n  QueryList.prototype.wouldCreatedItemMatchSomeExistingItem = function () {\n    var _this = this; // search only the filtered items, not the full items list, because we\n    // only need to check items that match the current query.\n\n\n    return this.state.filteredItems.some(function (item) {\n      return executeItemsEqual(_this.props.itemsEqual, item, _this.state.createNewItem);\n    });\n  };\n\n  QueryList.prototype.maybeResetQuery = function () {\n    if (this.props.resetOnSelect) {\n      this.setQuery(\"\", true);\n    }\n  };\n\n  QueryList.displayName = DISPLAYNAME_PREFIX + \".QueryList\";\n  QueryList.defaultProps = {\n    disabled: false,\n    resetOnQuery: true\n  };\n  return QueryList;\n}(AbstractComponent2);\n\nexport { QueryList };\n\nfunction pxToNumber(value) {\n  return value == null ? 0 : parseInt(value.slice(0, -2), 10);\n}\n\nfunction getMatchingItem(query, _a) {\n  var items = _a.items,\n      itemPredicate = _a.itemPredicate;\n\n  if (Utils.isFunction(itemPredicate)) {\n    // .find() doesn't exist in ES5. Alternative: use a for loop instead of\n    // .filter() so that we can return as soon as we find the first match.\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (itemPredicate(query, item, i, true)) {\n        return item;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getFilteredItems(query, _a) {\n  var items = _a.items,\n      itemPredicate = _a.itemPredicate,\n      itemListPredicate = _a.itemListPredicate;\n\n  if (Utils.isFunction(itemListPredicate)) {\n    // note that implementations can reorder the items here\n    return itemListPredicate(query, items);\n  } else if (Utils.isFunction(itemPredicate)) {\n    return items.filter(function (item, index) {\n      return itemPredicate(query, item, index);\n    });\n  }\n\n  return items;\n}\n/** Wrap number around min/max values: if it exceeds one bound, return the other. */\n\n\nfunction wrapNumber(value, min, max) {\n  if (value < min) {\n    return max;\n  } else if (value > max) {\n    return min;\n  }\n\n  return value;\n}\n\nfunction isItemDisabled(item, index, itemDisabled) {\n  if (itemDisabled == null || item == null) {\n    return false;\n  } else if (Utils.isFunction(itemDisabled)) {\n    return itemDisabled(item, index);\n  }\n\n  return !!item[itemDisabled];\n}\n/**\n * Get the next enabled item, moving in the given direction from the start\n * index. A `null` return value means no suitable item was found.\n *\n * @param items the list of items\n * @param itemDisabled callback to determine if a given item is disabled\n * @param direction amount to move in each iteration, typically +/-1\n * @param startIndex which index to begin moving from\n */\n\n\nexport function getFirstEnabledItem(items, itemDisabled, direction, startIndex) {\n  if (direction === void 0) {\n    direction = 1;\n  }\n\n  if (startIndex === void 0) {\n    startIndex = items.length - 1;\n  }\n\n  if (items.length === 0) {\n    return null;\n  } // remember where we started to prevent an infinite loop\n\n\n  var index = startIndex;\n  var maxIndex = items.length - 1;\n\n  do {\n    // find first non-disabled item\n    index = wrapNumber(index + direction, 0, maxIndex);\n\n    if (!isItemDisabled(items[index], index, itemDisabled)) {\n      return items[index];\n    }\n  } while (index !== startIndex && startIndex !== -1);\n\n  return null;\n}","map":{"version":3,"sources":["../../../../src/components/query-list/queryList.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __rest } from \"tslib\";\nimport * as React from \"react\";\nimport { AbstractComponent2, DISPLAYNAME_PREFIX, Keys, Menu, Utils } from \"@blueprintjs/core\";\nimport { executeItemsEqual, getActiveItem, getCreateNewItem, isCreateNewItem, renderFilteredItems, } from \"../../common\";\nvar QueryList = /** @class */ (function (_super) {\n    __extends(QueryList, _super);\n    function QueryList(props, context) {\n        var _a, _b;\n        var _this = _super.call(this, props, context) || this;\n        _this.refHandlers = {\n            itemsParent: function (ref) { return (_this.itemsParentRef = ref); },\n        };\n        /**\n         * Flag indicating that we should check whether selected item is in viewport\n         * after rendering, typically because of keyboard change. Set to `true` when\n         * manipulating state in a way that may cause active item to scroll away.\n         */\n        _this.shouldCheckActiveItemInViewport = false;\n        /**\n         * The item that we expect to be the next selected active item (based on click\n         * or key interactions). When scrollToActiveItem = false, used to detect if\n         * an unexpected external change to the active item has been made.\n         */\n        _this.expectedNextActiveItem = null;\n        /**\n         * Flag which is set to true while in between an ENTER \"keydown\" event and its\n         * corresponding \"keyup\" event.\n         *\n         * When entering text via an IME (https://en.wikipedia.org/wiki/Input_method),\n         * the ENTER key is pressed to confirm the character(s) to be input from a list\n         * of options. The operating system intercepts the ENTER \"keydown\" event and\n         * prevents it from propagating to the application, but \"keyup\" is still\n         * fired, triggering a spurious event which this component does not expect.\n         *\n         * To work around this quirk, we keep track of \"real\" key presses by setting\n         * this flag in handleKeyDown.\n         */\n        _this.isEnterKeyPressed = false;\n        /** default `itemListRenderer` implementation */\n        _this.renderItemList = function (listProps) {\n            var _a = _this.props, initialContent = _a.initialContent, noResults = _a.noResults;\n            // omit noResults if createNewItemFromQuery and createNewItemRenderer are both supplied, and query is not empty\n            var createItemView = listProps.renderCreateItem();\n            var maybeNoResults = createItemView != null ? null : noResults;\n            var menuContent = renderFilteredItems(listProps, maybeNoResults, initialContent);\n            if (menuContent == null && createItemView == null) {\n                return null;\n            }\n            var createFirst = _this.isCreateItemFirst();\n            return (React.createElement(Menu, { ulRef: listProps.itemsParentRef },\n                createFirst && createItemView,\n                menuContent,\n                !createFirst && createItemView));\n        };\n        /** wrapper around `itemRenderer` to inject props */\n        _this.renderItem = function (item, index) {\n            if (_this.props.disabled !== true) {\n                var _a = _this.state, activeItem = _a.activeItem, query = _a.query;\n                var matchesPredicate = _this.state.filteredItems.indexOf(item) >= 0;\n                var modifiers = {\n                    active: executeItemsEqual(_this.props.itemsEqual, getActiveItem(activeItem), item),\n                    disabled: isItemDisabled(item, index, _this.props.itemDisabled),\n                    matchesPredicate: matchesPredicate,\n                };\n                return _this.props.itemRenderer(item, {\n                    handleClick: function (e) { return _this.handleItemSelect(item, e); },\n                    index: index,\n                    modifiers: modifiers,\n                    query: query,\n                });\n            }\n            return null;\n        };\n        _this.renderCreateItemMenuItem = function () {\n            if (_this.isCreateItemRendered()) {\n                var _a = _this.state, activeItem = _a.activeItem, query = _a.query;\n                var trimmedQuery_1 = query.trim();\n                var handleClick = function (evt) {\n                    _this.handleItemCreate(trimmedQuery_1, evt);\n                };\n                var isActive = isCreateNewItem(activeItem);\n                return _this.props.createNewItemRenderer(trimmedQuery_1, isActive, handleClick);\n            }\n            return null;\n        };\n        _this.handleItemCreate = function (query, evt) {\n            var _a, _b, _c, _d;\n            // we keep a cached createNewItem in state, but might as well recompute\n            // the result just to be sure it's perfectly in sync with the query.\n            var item = (_b = (_a = _this.props).createNewItemFromQuery) === null || _b === void 0 ? void 0 : _b.call(_a, query);\n            if (item != null) {\n                (_d = (_c = _this.props).onItemSelect) === null || _d === void 0 ? void 0 : _d.call(_c, item, evt);\n                _this.maybeResetQuery();\n            }\n        };\n        _this.handleItemSelect = function (item, event) {\n            var _a, _b;\n            _this.setActiveItem(item);\n            (_b = (_a = _this.props).onItemSelect) === null || _b === void 0 ? void 0 : _b.call(_a, item, event);\n            _this.maybeResetQuery();\n        };\n        _this.handlePaste = function (queries) {\n            var _a = _this.props, createNewItemFromQuery = _a.createNewItemFromQuery, onItemsPaste = _a.onItemsPaste;\n            var nextActiveItem;\n            var nextQueries = [];\n            // Find an exising itemÂ that exactly matches each pasted value, or\n            // create a new item if possible. Ignore unmatched values if creating\n            // items is disabled.\n            var pastedItemsToEmit = [];\n            for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {\n                var query = queries_1[_i];\n                var equalItem = getMatchingItem(query, _this.props);\n                if (equalItem !== undefined) {\n                    nextActiveItem = equalItem;\n                    pastedItemsToEmit.push(equalItem);\n                }\n                else if (_this.canCreateItems()) {\n                    var newItem = createNewItemFromQuery === null || createNewItemFromQuery === void 0 ? void 0 : createNewItemFromQuery(query);\n                    if (newItem !== undefined) {\n                        pastedItemsToEmit.push(newItem);\n                    }\n                }\n                else {\n                    nextQueries.push(query);\n                }\n            }\n            // UX nicety: combine all unmatched queries into a single\n            // comma-separated query in the input, so we don't lose any information.\n            // And don't reset the active item; we'll do that ourselves below.\n            _this.setQuery(nextQueries.join(\", \"), false);\n            // UX nicety: update the active item if we matched with at least one\n            // existing item.\n            if (nextActiveItem !== undefined) {\n                _this.setActiveItem(nextActiveItem);\n            }\n            onItemsPaste === null || onItemsPaste === void 0 ? void 0 : onItemsPaste(pastedItemsToEmit);\n        };\n        _this.handleKeyDown = function (event) {\n            var _a, _b;\n            // eslint-disable-next-line deprecation/deprecation\n            var keyCode = event.keyCode;\n            if (keyCode === Keys.ARROW_UP || keyCode === Keys.ARROW_DOWN) {\n                event.preventDefault();\n                var nextActiveItem = _this.getNextActiveItem(keyCode === Keys.ARROW_UP ? -1 : 1);\n                if (nextActiveItem != null) {\n                    _this.setActiveItem(nextActiveItem);\n                }\n            }\n            else if (keyCode === Keys.ENTER) {\n                _this.isEnterKeyPressed = true;\n            }\n            (_b = (_a = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n        };\n        _this.handleKeyUp = function (event) {\n            var onKeyUp = _this.props.onKeyUp;\n            var activeItem = _this.state.activeItem;\n            // eslint-disable-next-line deprecation/deprecation\n            if (event.keyCode === Keys.ENTER && _this.isEnterKeyPressed) {\n                // We handle ENTER in keyup here to play nice with the Button component's keyboard\n                // clicking. Button is commonly used as the only child of Select. If we were to\n                // instead process ENTER on keydown, then Button would click itself on keyup and\n                // the Select popover would re-open.\n                event.preventDefault();\n                if (activeItem == null || isCreateNewItem(activeItem)) {\n                    _this.handleItemCreate(_this.state.query, event);\n                }\n                else {\n                    _this.handleItemSelect(activeItem, event);\n                }\n                _this.isEnterKeyPressed = false;\n            }\n            onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(event);\n        };\n        _this.handleInputQueryChange = function (event) {\n            var _a, _b;\n            var query = event == null ? \"\" : event.target.value;\n            _this.setQuery(query);\n            (_b = (_a = _this.props).onQueryChange) === null || _b === void 0 ? void 0 : _b.call(_a, query, event);\n        };\n        var _c = props.query, query = _c === void 0 ? \"\" : _c;\n        var createNewItem = (_a = props.createNewItemFromQuery) === null || _a === void 0 ? void 0 : _a.call(props, query);\n        var filteredItems = getFilteredItems(query, props);\n        _this.state = {\n            activeItem: props.activeItem !== undefined\n                ? props.activeItem\n                : (_b = props.initialActiveItem) !== null && _b !== void 0 ? _b : getFirstEnabledItem(filteredItems, props.itemDisabled),\n            createNewItem: createNewItem,\n            filteredItems: filteredItems,\n            query: query,\n        };\n        return _this;\n    }\n    QueryList.ofType = function () {\n        return QueryList;\n    };\n    QueryList.prototype.render = function () {\n        var _a = this.props, className = _a.className, items = _a.items, renderer = _a.renderer, _b = _a.itemListRenderer, itemListRenderer = _b === void 0 ? this.renderItemList : _b;\n        var _c = this.state, createNewItem = _c.createNewItem, spreadableState = __rest(_c, [\"createNewItem\"]);\n        return renderer(__assign(__assign({}, spreadableState), { className: className, handleItemSelect: this.handleItemSelect, handleKeyDown: this.handleKeyDown, handleKeyUp: this.handleKeyUp, handlePaste: this.handlePaste, handleQueryChange: this.handleInputQueryChange, itemList: itemListRenderer(__assign(__assign({}, spreadableState), { items: items, itemsParentRef: this.refHandlers.itemsParent, renderCreateItem: this.renderCreateItemMenuItem, renderItem: this.renderItem })) }));\n    };\n    QueryList.prototype.componentDidUpdate = function (prevProps) {\n        var _this = this;\n        if (this.props.activeItem !== undefined && this.props.activeItem !== this.state.activeItem) {\n            this.shouldCheckActiveItemInViewport = true;\n            this.setState({ activeItem: this.props.activeItem });\n        }\n        if (this.props.query != null && this.props.query !== prevProps.query) {\n            // new query\n            this.setQuery(this.props.query, this.props.resetOnQuery, this.props);\n        }\n        else if (\n        // same query (or uncontrolled query), but items in the list changed\n        !Utils.shallowCompareKeys(this.props, prevProps, {\n            include: [\"items\", \"itemListPredicate\", \"itemPredicate\"],\n        })) {\n            this.setQuery(this.state.query);\n        }\n        if (this.shouldCheckActiveItemInViewport) {\n            // update scroll position immediately before repaint so DOM is accurate\n            // (latest filteredItems) and to avoid flicker.\n            this.requestAnimationFrame(function () { return _this.scrollActiveItemIntoView(); });\n            // reset the flag\n            this.shouldCheckActiveItemInViewport = false;\n        }\n    };\n    QueryList.prototype.scrollActiveItemIntoView = function () {\n        var scrollToActiveItem = this.props.scrollToActiveItem !== false;\n        var externalChangeToActiveItem = !executeItemsEqual(this.props.itemsEqual, getActiveItem(this.expectedNextActiveItem), getActiveItem(this.props.activeItem));\n        this.expectedNextActiveItem = null;\n        if (!scrollToActiveItem && externalChangeToActiveItem) {\n            return;\n        }\n        var activeElement = this.getActiveElement();\n        if (this.itemsParentRef != null && activeElement != null) {\n            var activeTop = activeElement.offsetTop, activeHeight = activeElement.offsetHeight;\n            var _a = this.itemsParentRef, parentOffsetTop = _a.offsetTop, parentScrollTop = _a.scrollTop, parentHeight = _a.clientHeight;\n            // compute padding on parent element to ensure we always leave space\n            var _b = this.getItemsParentPadding(), paddingTop = _b.paddingTop, paddingBottom = _b.paddingBottom;\n            // compute the two edges of the active item for comparison, including parent padding\n            var activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;\n            var activeTopEdge = activeTop - paddingTop - parentOffsetTop;\n            if (activeBottomEdge >= parentScrollTop + parentHeight) {\n                // offscreen bottom: align bottom of item with bottom of viewport\n                this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;\n            }\n            else if (activeTopEdge <= parentScrollTop) {\n                // offscreen top: align top of item with top of viewport\n                this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;\n            }\n        }\n    };\n    QueryList.prototype.setQuery = function (query, resetActiveItem, props) {\n        var _a;\n        if (resetActiveItem === void 0) { resetActiveItem = this.props.resetOnQuery; }\n        if (props === void 0) { props = this.props; }\n        var createNewItemFromQuery = props.createNewItemFromQuery;\n        this.shouldCheckActiveItemInViewport = true;\n        var hasQueryChanged = query !== this.state.query;\n        if (hasQueryChanged) {\n            (_a = props.onQueryChange) === null || _a === void 0 ? void 0 : _a.call(props, query);\n        }\n        // Leading and trailing whitespace can be confusing to display, so we remove it when passing it\n        // to functions dealing with data, like createNewItemFromQuery. But we need the unaltered user-typed\n        // query to remain in state to be able to render controlled text inputs properly.\n        var trimmedQuery = query.trim();\n        var filteredItems = getFilteredItems(trimmedQuery, props);\n        var createNewItem = createNewItemFromQuery != null && trimmedQuery !== \"\" ? createNewItemFromQuery(trimmedQuery) : undefined;\n        this.setState({ createNewItem: createNewItem, filteredItems: filteredItems, query: query });\n        // always reset active item if it's now filtered or disabled\n        var activeIndex = this.getActiveIndex(filteredItems);\n        var shouldUpdateActiveItem = resetActiveItem ||\n            activeIndex < 0 ||\n            isItemDisabled(getActiveItem(this.state.activeItem), activeIndex, props.itemDisabled);\n        if (shouldUpdateActiveItem) {\n            // if the `createNewItem` is first, that should be the first active item.\n            if (this.isCreateItemRendered() && this.isCreateItemFirst()) {\n                this.setActiveItem(getCreateNewItem());\n            }\n            else {\n                this.setActiveItem(getFirstEnabledItem(filteredItems, props.itemDisabled));\n            }\n        }\n    };\n    QueryList.prototype.setActiveItem = function (activeItem) {\n        var _a, _b, _c, _d;\n        this.expectedNextActiveItem = activeItem;\n        if (this.props.activeItem === undefined) {\n            // indicate that the active item may need to be scrolled into view after update.\n            this.shouldCheckActiveItemInViewport = true;\n            this.setState({ activeItem: activeItem });\n        }\n        if (isCreateNewItem(activeItem)) {\n            (_b = (_a = this.props).onActiveItemChange) === null || _b === void 0 ? void 0 : _b.call(_a, null, true);\n        }\n        else {\n            (_d = (_c = this.props).onActiveItemChange) === null || _d === void 0 ? void 0 : _d.call(_c, activeItem, false);\n        }\n    };\n    QueryList.prototype.getActiveElement = function () {\n        var activeItem = this.state.activeItem;\n        if (this.itemsParentRef != null) {\n            if (isCreateNewItem(activeItem)) {\n                var index = this.isCreateItemFirst() ? 0 : this.state.filteredItems.length;\n                return this.itemsParentRef.children.item(index);\n            }\n            else {\n                var activeIndex = this.getActiveIndex();\n                return this.itemsParentRef.children.item(activeIndex);\n            }\n        }\n        return undefined;\n    };\n    QueryList.prototype.getActiveIndex = function (items) {\n        if (items === void 0) { items = this.state.filteredItems; }\n        var activeItem = this.state.activeItem;\n        if (activeItem == null || isCreateNewItem(activeItem)) {\n            return -1;\n        }\n        // NOTE: this operation is O(n) so it should be avoided in render(). safe for events though.\n        for (var i = 0; i < items.length; ++i) {\n            if (executeItemsEqual(this.props.itemsEqual, items[i], activeItem)) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    QueryList.prototype.getItemsParentPadding = function () {\n        // assert ref exists because it was checked before calling\n        var _a = getComputedStyle(this.itemsParentRef), paddingTop = _a.paddingTop, paddingBottom = _a.paddingBottom;\n        return {\n            paddingBottom: pxToNumber(paddingBottom),\n            paddingTop: pxToNumber(paddingTop),\n        };\n    };\n    /**\n     * Get the next enabled item, moving in the given direction from the start\n     * index. A `null` return value means no suitable item was found.\n     *\n     * @param direction amount to move in each iteration, typically +/-1\n     * @param startIndex item to start iteration\n     */\n    QueryList.prototype.getNextActiveItem = function (direction, startIndex) {\n        if (startIndex === void 0) { startIndex = this.getActiveIndex(); }\n        if (this.isCreateItemRendered()) {\n            var reachedCreate = (startIndex === 0 && direction === -1) ||\n                (startIndex === this.state.filteredItems.length - 1 && direction === 1);\n            if (reachedCreate) {\n                return getCreateNewItem();\n            }\n        }\n        return getFirstEnabledItem(this.state.filteredItems, this.props.itemDisabled, direction, startIndex);\n    };\n    QueryList.prototype.isCreateItemRendered = function () {\n        return (this.canCreateItems() &&\n            this.state.query !== \"\" &&\n            // this check is unfortunately O(N) on the number of items, but\n            // alas, hiding the \"Create Item\" option when it exactly matches an\n            // existing item is much clearer.\n            !this.wouldCreatedItemMatchSomeExistingItem());\n    };\n    QueryList.prototype.isCreateItemFirst = function () {\n        return this.props.createNewItemPosition === \"first\";\n    };\n    QueryList.prototype.canCreateItems = function () {\n        return this.props.createNewItemFromQuery != null && this.props.createNewItemRenderer != null;\n    };\n    QueryList.prototype.wouldCreatedItemMatchSomeExistingItem = function () {\n        var _this = this;\n        // search only the filtered items, not the full items list, because we\n        // only need to check items that match the current query.\n        return this.state.filteredItems.some(function (item) {\n            return executeItemsEqual(_this.props.itemsEqual, item, _this.state.createNewItem);\n        });\n    };\n    QueryList.prototype.maybeResetQuery = function () {\n        if (this.props.resetOnSelect) {\n            this.setQuery(\"\", true);\n        }\n    };\n    QueryList.displayName = DISPLAYNAME_PREFIX + \".QueryList\";\n    QueryList.defaultProps = {\n        disabled: false,\n        resetOnQuery: true,\n    };\n    return QueryList;\n}(AbstractComponent2));\nexport { QueryList };\nfunction pxToNumber(value) {\n    return value == null ? 0 : parseInt(value.slice(0, -2), 10);\n}\nfunction getMatchingItem(query, _a) {\n    var items = _a.items, itemPredicate = _a.itemPredicate;\n    if (Utils.isFunction(itemPredicate)) {\n        // .find() doesn't exist in ES5. Alternative: use a for loop instead of\n        // .filter() so that we can return as soon as we find the first match.\n        for (var i = 0; i < items.length; i++) {\n            var item = items[i];\n            if (itemPredicate(query, item, i, true)) {\n                return item;\n            }\n        }\n    }\n    return undefined;\n}\nfunction getFilteredItems(query, _a) {\n    var items = _a.items, itemPredicate = _a.itemPredicate, itemListPredicate = _a.itemListPredicate;\n    if (Utils.isFunction(itemListPredicate)) {\n        // note that implementations can reorder the items here\n        return itemListPredicate(query, items);\n    }\n    else if (Utils.isFunction(itemPredicate)) {\n        return items.filter(function (item, index) { return itemPredicate(query, item, index); });\n    }\n    return items;\n}\n/** Wrap number around min/max values: if it exceeds one bound, return the other. */\nfunction wrapNumber(value, min, max) {\n    if (value < min) {\n        return max;\n    }\n    else if (value > max) {\n        return min;\n    }\n    return value;\n}\nfunction isItemDisabled(item, index, itemDisabled) {\n    if (itemDisabled == null || item == null) {\n        return false;\n    }\n    else if (Utils.isFunction(itemDisabled)) {\n        return itemDisabled(item, index);\n    }\n    return !!item[itemDisabled];\n}\n/**\n * Get the next enabled item, moving in the given direction from the start\n * index. A `null` return value means no suitable item was found.\n *\n * @param items the list of items\n * @param itemDisabled callback to determine if a given item is disabled\n * @param direction amount to move in each iteration, typically +/-1\n * @param startIndex which index to begin moving from\n */\nexport function getFirstEnabledItem(items, itemDisabled, direction, startIndex) {\n    if (direction === void 0) { direction = 1; }\n    if (startIndex === void 0) { startIndex = items.length - 1; }\n    if (items.length === 0) {\n        return null;\n    }\n    // remember where we started to prevent an infinite loop\n    var index = startIndex;\n    var maxIndex = items.length - 1;\n    do {\n        // find first non-disabled item\n        index = wrapNumber(index + direction, 0, maxIndex);\n        if (!isItemDisabled(items[index], index, itemDisabled)) {\n            return items[index];\n        }\n    } while (index !== startIndex && startIndex !== -1);\n    return null;\n}\n//# sourceMappingURL=queryList.js.map"]},"metadata":{},"sourceType":"module"}