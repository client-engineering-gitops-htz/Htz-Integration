{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport DayPicker from \"react-day-picker\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Boundary, Classes, DISPLAYNAME_PREFIX, InputGroup, Intent, Keys, Popover, Position, refHandler, setRef } from \"@blueprintjs/core\";\nimport { areSameTime, isDateValid, isDayInRange } from \"./common/dateUtils\";\nimport * as Errors from \"./common/errors\";\nimport { getFormattedDateString } from \"./dateFormat\";\nimport { getDefaultMaxDate, getDefaultMinDate } from \"./datePickerCore\";\nimport { DateRangePicker } from \"./dateRangePicker\";\n\nvar DateRangeInput =\n/** @class */\nfunction (_super) {\n  __extends(DateRangeInput, _super);\n\n  function DateRangeInput(props, context) {\n    var _a, _b;\n\n    var _this = _super.call(this, props, context) || this;\n\n    _this.startInputElement = null;\n    _this.endInputElement = null;\n    _this.handleStartInputRef = refHandler(_this, \"startInputElement\", (_a = _this.props.startInputProps) === null || _a === void 0 ? void 0 : _a.inputRef);\n    _this.handleEndInputRef = refHandler(_this, \"endInputElement\", (_b = _this.props.endInputProps) === null || _b === void 0 ? void 0 : _b.inputRef);\n\n    _this.renderInputGroup = function (boundary) {\n      var inputProps = _this.getInputProps(boundary);\n\n      var handleInputEvent = boundary === Boundary.START ? _this.handleStartInputEvent : _this.handleEndInputEvent;\n      return React.createElement(InputGroup, __assign({\n        autoComplete: \"off\",\n        disabled: inputProps.disabled || _this.props.disabled\n      }, inputProps, {\n        intent: _this.isInputInErrorState(boundary) ? Intent.DANGER : inputProps.intent,\n        inputRef: _this.getInputRef(boundary),\n        onBlur: handleInputEvent,\n        onChange: handleInputEvent,\n        onClick: handleInputEvent,\n        onFocus: handleInputEvent,\n        onKeyDown: handleInputEvent,\n        onMouseDown: handleInputEvent,\n        placeholder: _this.getInputPlaceholderString(boundary),\n        value: _this.getInputDisplayString(boundary)\n      }));\n    }; // Callbacks - DateRangePicker\n    // ===========================\n\n\n    _this.handleDateRangePickerChange = function (selectedRange, didSubmitWithEnter) {\n      var _a, _b;\n\n      if (didSubmitWithEnter === void 0) {\n        didSubmitWithEnter = false;\n      } // ignore mouse events in the date-range picker if the popover is animating closed.\n\n\n      if (!_this.state.isOpen) {\n        return;\n      }\n\n      var selectedStart = selectedRange[0],\n          selectedEnd = selectedRange[1];\n      var isOpen = true;\n      var isStartInputFocused;\n      var isEndInputFocused;\n      var startHoverString;\n      var endHoverString;\n      var boundaryToModify;\n\n      if (selectedStart == null) {\n        // focus the start field by default or if only an end date is specified\n        if (_this.props.timePrecision == null) {\n          isStartInputFocused = true;\n          isEndInputFocused = false;\n        } else {\n          isStartInputFocused = false;\n          isEndInputFocused = false;\n          boundaryToModify = Boundary.START;\n        } // for clarity, hide the hover string until the mouse moves over a different date\n\n\n        startHoverString = null;\n      } else if (selectedEnd == null) {\n        // focus the end field if a start date is specified\n        if (_this.props.timePrecision == null) {\n          isStartInputFocused = false;\n          isEndInputFocused = true;\n        } else {\n          isStartInputFocused = false;\n          isEndInputFocused = false;\n          boundaryToModify = Boundary.END;\n        }\n\n        endHoverString = null;\n      } else if (_this.props.closeOnSelection) {\n        isOpen = _this.getIsOpenValueWhenDateChanges(selectedStart, selectedEnd);\n        isStartInputFocused = false;\n\n        if (_this.props.timePrecision == null && didSubmitWithEnter) {\n          // if we submit via click or Tab, the focus will have moved already.\n          // it we submit with Enter, the focus won't have moved, and setting\n          // the flag to false won't have an effect anyway, so leave it true.\n          isEndInputFocused = true;\n        } else {\n          isEndInputFocused = false;\n          boundaryToModify = Boundary.END;\n        }\n      } else if (_this.state.lastFocusedField === Boundary.START) {\n        // keep the start field focused\n        if (_this.props.timePrecision == null) {\n          isStartInputFocused = true;\n          isEndInputFocused = false;\n        } else {\n          isStartInputFocused = false;\n          isEndInputFocused = false;\n          boundaryToModify = Boundary.START;\n        }\n      } else if (_this.props.timePrecision == null) {\n        // keep the end field focused\n        isStartInputFocused = false;\n        isEndInputFocused = true;\n      } else {\n        isStartInputFocused = false;\n        isEndInputFocused = false;\n        boundaryToModify = Boundary.END;\n      }\n\n      var baseStateChange = {\n        boundaryToModify: boundaryToModify,\n        endHoverString: endHoverString,\n        endInputString: _this.formatDate(selectedEnd),\n        isEndInputFocused: isEndInputFocused,\n        isOpen: isOpen,\n        isStartInputFocused: isStartInputFocused,\n        startHoverString: startHoverString,\n        startInputString: _this.formatDate(selectedStart),\n        wasLastFocusChangeDueToHover: false\n      };\n\n      if (_this.isControlled()) {\n        _this.setState(baseStateChange);\n      } else {\n        _this.setState(__assign(__assign({}, baseStateChange), {\n          selectedEnd: selectedEnd,\n          selectedStart: selectedStart\n        }));\n      }\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, selectedRange);\n    };\n\n    _this.handleShortcutChange = function (_, selectedShortcutIndex) {\n      _this.setState({\n        selectedShortcutIndex: selectedShortcutIndex\n      });\n    };\n\n    _this.handleDateRangePickerHoverChange = function (hoveredRange, _hoveredDay, hoveredBoundary) {\n      // ignore mouse events in the date-range picker if the popover is animating closed.\n      if (!_this.state.isOpen) {\n        return;\n      }\n\n      if (hoveredRange == null) {\n        // undo whatever focus changes we made while hovering over various calendar dates\n        var isEndInputFocused = _this.state.boundaryToModify === Boundary.END;\n\n        _this.setState({\n          endHoverString: null,\n          isEndInputFocused: isEndInputFocused,\n          isStartInputFocused: !isEndInputFocused,\n          lastFocusedField: _this.state.boundaryToModify,\n          startHoverString: null\n        });\n      } else {\n        var hoveredStart = hoveredRange[0],\n            hoveredEnd = hoveredRange[1];\n        var isStartInputFocused = hoveredBoundary != null ? hoveredBoundary === Boundary.START : _this.state.isStartInputFocused;\n        var isEndInputFocused = hoveredBoundary != null ? hoveredBoundary === Boundary.END : _this.state.isEndInputFocused;\n\n        _this.setState({\n          endHoverString: _this.formatDate(hoveredEnd),\n          isEndInputFocused: isEndInputFocused,\n          isStartInputFocused: isStartInputFocused,\n          lastFocusedField: isStartInputFocused ? Boundary.START : Boundary.END,\n          shouldSelectAfterUpdate: _this.props.selectAllOnFocus,\n          startHoverString: _this.formatDate(hoveredStart),\n          wasLastFocusChangeDueToHover: true\n        });\n      }\n    }; // Callbacks - Input\n    // =================\n    // instantiate these two functions once so we don't have to for each callback on each render.\n\n\n    _this.handleStartInputEvent = function (e) {\n      _this.handleInputEvent(e, Boundary.START);\n    };\n\n    _this.handleEndInputEvent = function (e) {\n      _this.handleInputEvent(e, Boundary.END);\n    };\n\n    _this.handleInputEvent = function (e, boundary) {\n      var _a, _b, _c, _d, _f, _g;\n\n      var inputProps = _this.getInputProps(boundary);\n\n      switch (e.type) {\n        case \"blur\":\n          _this.handleInputBlur(e, boundary);\n\n          (_a = inputProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(inputProps, e);\n          break;\n\n        case \"change\":\n          _this.handleInputChange(e, boundary);\n\n          (_b = inputProps.onChange) === null || _b === void 0 ? void 0 : _b.call(inputProps, e);\n          break;\n\n        case \"click\":\n          e = e;\n\n          _this.handleInputClick(e);\n\n          (_c = inputProps.onClick) === null || _c === void 0 ? void 0 : _c.call(inputProps, e);\n          break;\n\n        case \"focus\":\n          _this.handleInputFocus(e, boundary);\n\n          (_d = inputProps.onFocus) === null || _d === void 0 ? void 0 : _d.call(inputProps, e);\n          break;\n\n        case \"keydown\":\n          e = e;\n\n          _this.handleInputKeyDown(e);\n\n          (_f = inputProps.onKeyDown) === null || _f === void 0 ? void 0 : _f.call(inputProps, e);\n          break;\n\n        case \"mousedown\":\n          e = e;\n\n          _this.handleInputMouseDown();\n\n          (_g = inputProps.onMouseDown) === null || _g === void 0 ? void 0 : _g.call(inputProps, e);\n          break;\n\n        default:\n          break;\n      }\n    }; // add a keydown listener to persistently change focus when tabbing:\n    // - if focused in start field, Tab moves focus to end field\n    // - if focused in end field, Shift+Tab moves focus to start field\n\n\n    _this.handleInputKeyDown = function (e) {\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n\n      /* eslint-disable deprecation/deprecation */\n      var isTabPressed = e.which === Keys.TAB;\n      var isEnterPressed = e.which === Keys.ENTER;\n      var isShiftPressed = e.shiftKey;\n      var _a = _this.state,\n          selectedStart = _a.selectedStart,\n          selectedEnd = _a.selectedEnd; // order of JS events is our enemy here. when tabbing between fields,\n      // this handler will fire in the middle of a focus exchange when no\n      // field is currently focused. we work around this by referring to the\n      // most recently focused field, rather than the currently focused field.\n\n      var wasStartFieldFocused = _this.state.lastFocusedField === Boundary.START;\n      var wasEndFieldFocused = _this.state.lastFocusedField === Boundary.END; // move focus to the other field\n\n      if (isTabPressed) {\n        var isEndInputFocused = void 0;\n        var isStartInputFocused = void 0;\n        var isOpen = true;\n\n        if (wasStartFieldFocused && !isShiftPressed) {\n          isStartInputFocused = false;\n          isEndInputFocused = true; // prevent the default focus-change behavior to avoid race conditions;\n          // we'll handle the focus change ourselves in componentDidUpdate.\n\n          e.preventDefault();\n        } else if (wasEndFieldFocused && isShiftPressed) {\n          isStartInputFocused = true;\n          isEndInputFocused = false;\n          e.preventDefault();\n        } else {\n          // don't prevent default here, otherwise Tab won't do anything.\n          isStartInputFocused = false;\n          isEndInputFocused = false;\n          isOpen = false;\n        }\n\n        _this.setState({\n          isEndInputFocused: isEndInputFocused,\n          isOpen: isOpen,\n          isStartInputFocused: isStartInputFocused,\n          wasLastFocusChangeDueToHover: false\n        });\n      } else if (wasStartFieldFocused && isEnterPressed) {\n        var nextStartDate = _this.parseDate(_this.state.startInputString);\n\n        _this.handleDateRangePickerChange([nextStartDate, selectedEnd], true);\n      } else if (wasEndFieldFocused && isEnterPressed) {\n        var nextEndDate = _this.parseDate(_this.state.endInputString);\n\n        _this.handleDateRangePickerChange([selectedStart, nextEndDate], true);\n      } else {\n        // let the default keystroke happen without side effects\n        return;\n      }\n    };\n\n    _this.handleInputMouseDown = function () {\n      // clicking in the field constitutes an explicit focus change. we update\n      // the flag on \"mousedown\" instead of on \"click\", because it needs to be\n      // set before onFocus is called (\"click\" triggers after \"focus\").\n      _this.setState({\n        wasLastFocusChangeDueToHover: false\n      });\n    };\n\n    _this.handleInputClick = function (e) {\n      // unless we stop propagation on this event, a click within an input\n      // will close the popover almost as soon as it opens.\n      e.stopPropagation();\n    };\n\n    _this.handleInputFocus = function (_e, boundary) {\n      var _a;\n\n      var _b = _this.getStateKeysAndValuesForBoundary(boundary),\n          keys = _b.keys,\n          values = _b.values;\n\n      var inputString = getFormattedDateString(values.selectedValue, _this.props, true); // change the boundary only if the user explicitly focused in the field.\n      // focus changes from hovering don't count; they're just temporary.\n\n      var boundaryToModify = _this.state.wasLastFocusChangeDueToHover ? _this.state.boundaryToModify : boundary;\n\n      _this.setState((_a = {}, _a[keys.inputString] = inputString, _a[keys.isInputFocused] = true, _a.boundaryToModify = boundaryToModify, _a.isOpen = true, _a.lastFocusedField = boundary, _a.shouldSelectAfterUpdate = _this.props.selectAllOnFocus, _a.wasLastFocusChangeDueToHover = false, _a));\n    };\n\n    _this.handleInputBlur = function (_e, boundary) {\n      var _a, _b, _c, _d;\n\n      var _f, _g;\n\n      var _h = _this.getStateKeysAndValuesForBoundary(boundary),\n          keys = _h.keys,\n          values = _h.values;\n\n      var maybeNextDate = _this.parseDate(values.inputString);\n\n      var isValueControlled = _this.isControlled();\n\n      var nextState = (_a = {}, _a[keys.isInputFocused] = false, _a.shouldSelectAfterUpdate = false, _a);\n\n      if (_this.isInputEmpty(values.inputString)) {\n        if (isValueControlled) {\n          nextState = __assign(__assign({}, nextState), (_b = {}, _b[keys.inputString] = getFormattedDateString(values.controlledValue, _this.props), _b));\n        } else {\n          nextState = __assign(__assign({}, nextState), (_c = {}, _c[keys.inputString] = null, _c[keys.selectedValue] = null, _c));\n        }\n      } else if (!_this.isNextDateRangeValid(maybeNextDate, boundary)) {\n        if (!isValueControlled) {\n          nextState = __assign(__assign({}, nextState), (_d = {}, _d[keys.inputString] = null, _d[keys.selectedValue] = maybeNextDate, _d));\n        }\n\n        (_g = (_f = _this.props).onError) === null || _g === void 0 ? void 0 : _g.call(_f, _this.getDateRangeForCallback(maybeNextDate, boundary));\n      }\n\n      _this.setState(nextState);\n    };\n\n    _this.handleInputChange = function (e, boundary) {\n      var _a, _b, _c, _d, _f;\n\n      var _g, _h, _j, _k;\n\n      var inputString = e.target.value;\n\n      var keys = _this.getStateKeysAndValuesForBoundary(boundary).keys;\n\n      var maybeNextDate = _this.parseDate(inputString);\n\n      var isValueControlled = _this.isControlled();\n\n      var nextState = {\n        shouldSelectAfterUpdate: false\n      };\n\n      if (inputString.length === 0) {\n        // this case will be relevant when we start showing the hovered range in the input\n        // fields. goal is to show an empty field for clarity until the mouse moves over a\n        // different date.\n        var baseState = __assign(__assign({}, nextState), (_a = {}, _a[keys.inputString] = \"\", _a));\n\n        if (isValueControlled) {\n          nextState = baseState;\n        } else {\n          nextState = __assign(__assign({}, baseState), (_b = {}, _b[keys.selectedValue] = null, _b));\n        }\n\n        (_h = (_g = _this.props).onChange) === null || _h === void 0 ? void 0 : _h.call(_g, _this.getDateRangeForCallback(null, boundary));\n      } else if (_this.isDateValidAndInRange(maybeNextDate)) {\n        // note that error cases that depend on both fields (e.g. overlapping dates) should fall\n        // through into this block so that the UI can update immediately, possibly with an error\n        // message on the other field.\n        // also, clear the hover string to ensure the most recent keystroke appears.\n        var baseState = __assign(__assign({}, nextState), (_c = {}, _c[keys.hoverString] = null, _c[keys.inputString] = inputString, _c));\n\n        if (isValueControlled) {\n          nextState = baseState;\n        } else {\n          nextState = __assign(__assign({}, baseState), (_d = {}, _d[keys.selectedValue] = maybeNextDate, _d));\n        }\n\n        if (_this.isNextDateRangeValid(maybeNextDate, boundary)) {\n          (_k = (_j = _this.props).onChange) === null || _k === void 0 ? void 0 : _k.call(_j, _this.getDateRangeForCallback(maybeNextDate, boundary));\n        }\n      } else {\n        // again, clear the hover string to ensure the most recent keystroke appears\n        nextState = __assign(__assign({}, nextState), (_f = {}, _f[keys.inputString] = inputString, _f[keys.hoverString] = null, _f));\n      }\n\n      _this.setState(nextState);\n    }; // Callbacks - Popover\n    // ===================\n\n\n    _this.handlePopoverClose = function (event) {\n      var _a, _b;\n\n      _this.setState({\n        isOpen: false\n      });\n\n      (_b = (_a = _this.props.popoverProps).onClose) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    };\n\n    _this.getIsOpenValueWhenDateChanges = function (nextSelectedStart, nextSelectedEnd) {\n      if (_this.props.closeOnSelection) {\n        // trivial case when TimePicker is not shown\n        if (_this.props.timePrecision == null) {\n          return false;\n        }\n\n        var fallbackDate = new Date(new Date().setHours(0, 0, 0, 0));\n\n        var _a = _this.getSelectedRange([fallbackDate, fallbackDate]),\n            selectedStart = _a[0],\n            selectedEnd = _a[1]; // case to check if the user has changed TimePicker values\n\n\n        if (areSameTime(selectedStart, nextSelectedStart) === true && areSameTime(selectedEnd, nextSelectedEnd) === true) {\n          return false;\n        }\n\n        return true;\n      }\n\n      return true;\n    };\n\n    _this.getInitialRange = function (props) {\n      if (props === void 0) {\n        props = _this.props;\n      }\n\n      var defaultValue = props.defaultValue,\n          value = props.value;\n\n      if (value != null) {\n        return value;\n      } else if (defaultValue != null) {\n        return defaultValue;\n      } else {\n        return [null, null];\n      }\n    };\n\n    _this.getSelectedRange = function (fallbackRange) {\n      var _a;\n\n      var selectedStart;\n      var selectedEnd;\n\n      if (_this.isControlled()) {\n        _a = _this.props.value, selectedStart = _a[0], selectedEnd = _a[1];\n      } else {\n        selectedStart = _this.state.selectedStart;\n        selectedEnd = _this.state.selectedEnd;\n      } // this helper function checks if the provided boundary date *would* overlap the selected\n      // other boundary date. providing the already-selected start date simply tells us if we're\n      // currently in an overlapping state.\n\n\n      var doBoundaryDatesOverlap = _this.doBoundaryDatesOverlap(selectedStart, Boundary.START);\n\n      var dateRange = [selectedStart, doBoundaryDatesOverlap ? undefined : selectedEnd];\n      return dateRange.map(function (selectedBound, index) {\n        var fallbackDate = fallbackRange != null ? fallbackRange[index] : undefined;\n        return _this.isDateValidAndInRange(selectedBound) ? selectedBound : fallbackDate;\n      });\n    };\n\n    _this.getInputDisplayString = function (boundary) {\n      var values = _this.getStateKeysAndValuesForBoundary(boundary).values;\n\n      var isInputFocused = values.isInputFocused,\n          inputString = values.inputString,\n          selectedValue = values.selectedValue,\n          hoverString = values.hoverString;\n\n      if (hoverString != null) {\n        return hoverString;\n      } else if (isInputFocused) {\n        return inputString == null ? \"\" : inputString;\n      } else if (selectedValue == null) {\n        return \"\";\n      } else if (_this.doesEndBoundaryOverlapStartBoundary(selectedValue, boundary)) {\n        return _this.props.overlappingDatesMessage;\n      } else {\n        return getFormattedDateString(selectedValue, _this.props);\n      }\n    };\n\n    _this.getInputPlaceholderString = function (boundary) {\n      var isStartBoundary = boundary === Boundary.START;\n      var isEndBoundary = boundary === Boundary.END;\n\n      var inputProps = _this.getInputProps(boundary);\n\n      var isInputFocused = _this.getStateKeysAndValuesForBoundary(boundary).values.isInputFocused; // use the custom placeholder text for the input, if providied\n\n\n      if (inputProps.placeholder != null) {\n        return inputProps.placeholder;\n      } else if (isStartBoundary) {\n        return isInputFocused ? _this.state.formattedMinDateString : \"Start date\";\n      } else if (isEndBoundary) {\n        return isInputFocused ? _this.state.formattedMaxDateString : \"End date\";\n      } else {\n        return \"\";\n      }\n    };\n\n    _this.getInputProps = function (boundary) {\n      return boundary === Boundary.START ? _this.props.startInputProps : _this.props.endInputProps;\n    };\n\n    _this.getInputRef = function (boundary) {\n      return boundary === Boundary.START ? _this.handleStartInputRef : _this.handleEndInputRef;\n    };\n\n    _this.getStateKeysAndValuesForBoundary = function (boundary) {\n      var controlledRange = _this.props.value;\n\n      if (boundary === Boundary.START) {\n        return {\n          keys: {\n            hoverString: \"startHoverString\",\n            inputString: \"startInputString\",\n            isInputFocused: \"isStartInputFocused\",\n            selectedValue: \"selectedStart\"\n          },\n          values: {\n            controlledValue: controlledRange != null ? controlledRange[0] : undefined,\n            hoverString: _this.state.startHoverString,\n            inputString: _this.state.startInputString,\n            isInputFocused: _this.state.isStartInputFocused,\n            selectedValue: _this.state.selectedStart\n          }\n        };\n      } else {\n        return {\n          keys: {\n            hoverString: \"endHoverString\",\n            inputString: \"endInputString\",\n            isInputFocused: \"isEndInputFocused\",\n            selectedValue: \"selectedEnd\"\n          },\n          values: {\n            controlledValue: controlledRange != null ? controlledRange[1] : undefined,\n            hoverString: _this.state.endHoverString,\n            inputString: _this.state.endInputString,\n            isInputFocused: _this.state.isEndInputFocused,\n            selectedValue: _this.state.selectedEnd\n          }\n        };\n      }\n    };\n\n    _this.getDateRangeForCallback = function (currDate, currBoundary) {\n      var otherBoundary = _this.getOtherBoundary(currBoundary);\n\n      var otherDate = _this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n\n      return currBoundary === Boundary.START ? [currDate, otherDate] : [otherDate, currDate];\n    };\n\n    _this.getOtherBoundary = function (boundary) {\n      return boundary === Boundary.START ? Boundary.END : Boundary.START;\n    };\n\n    _this.doBoundaryDatesOverlap = function (date, boundary) {\n      var allowSingleDayRange = _this.props.allowSingleDayRange;\n\n      var otherBoundary = _this.getOtherBoundary(boundary);\n\n      var otherBoundaryDate = _this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n\n      if (date == null || otherBoundaryDate == null) {\n        return false;\n      }\n\n      if (boundary === Boundary.START) {\n        var isAfter = date > otherBoundaryDate;\n        return isAfter || !allowSingleDayRange && DayPicker.DateUtils.isSameDay(date, otherBoundaryDate);\n      } else {\n        var isBefore = date < otherBoundaryDate;\n        return isBefore || !allowSingleDayRange && DayPicker.DateUtils.isSameDay(date, otherBoundaryDate);\n      }\n    };\n    /**\n     * Returns true if the provided boundary is an END boundary overlapping the\n     * selected start date. (If the boundaries overlap, we consider the END\n     * boundary to be erroneous.)\n     */\n\n\n    _this.doesEndBoundaryOverlapStartBoundary = function (boundaryDate, boundary) {\n      return boundary === Boundary.START ? false : _this.doBoundaryDatesOverlap(boundaryDate, boundary);\n    };\n\n    _this.isControlled = function () {\n      return _this.props.value !== undefined;\n    };\n\n    _this.isInputEmpty = function (inputString) {\n      return inputString == null || inputString.length === 0;\n    };\n\n    _this.isInputInErrorState = function (boundary) {\n      var values = _this.getStateKeysAndValuesForBoundary(boundary).values;\n\n      var isInputFocused = values.isInputFocused,\n          hoverString = values.hoverString,\n          inputString = values.inputString,\n          selectedValue = values.selectedValue;\n\n      if (hoverString != null || _this.isInputEmpty(inputString)) {\n        // don't show an error state while we're hovering over a valid date.\n        return false;\n      }\n\n      var boundaryValue = isInputFocused ? _this.parseDate(inputString) : selectedValue;\n      return boundaryValue != null && (!_this.isDateValidAndInRange(boundaryValue) || _this.doesEndBoundaryOverlapStartBoundary(boundaryValue, boundary));\n    };\n\n    _this.isDateValidAndInRange = function (date) {\n      return isDateValid(date) && isDayInRange(date, [_this.props.minDate, _this.props.maxDate]);\n    };\n\n    _this.reset(props);\n\n    return _this;\n  }\n\n  DateRangeInput_1 = DateRangeInput;\n  /**\n   * Public method intended for unit testing only. Do not use in feature work!\n   */\n\n  DateRangeInput.prototype.reset = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var _a = this.getInitialRange(),\n        selectedStart = _a[0],\n        selectedEnd = _a[1];\n\n    this.state = {\n      formattedMaxDateString: this.getFormattedMinMaxDateString(props, \"maxDate\"),\n      formattedMinDateString: this.getFormattedMinMaxDateString(props, \"minDate\"),\n      isOpen: false,\n      selectedEnd: selectedEnd,\n      selectedShortcutIndex: -1,\n      selectedStart: selectedStart\n    };\n  };\n\n  DateRangeInput.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b, _c, _d, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n\n    var _r = this.state,\n        isStartInputFocused = _r.isStartInputFocused,\n        isEndInputFocused = _r.isEndInputFocused,\n        shouldSelectAfterUpdate = _r.shouldSelectAfterUpdate;\n\n    if (((_a = prevProps.startInputProps) === null || _a === void 0 ? void 0 : _a.inputRef) !== ((_b = this.props.startInputProps) === null || _b === void 0 ? void 0 : _b.inputRef)) {\n      setRef((_c = prevProps.startInputProps) === null || _c === void 0 ? void 0 : _c.inputRef, null);\n      this.handleStartInputRef = refHandler(this, \"startInputElement\", (_d = this.props.startInputProps) === null || _d === void 0 ? void 0 : _d.inputRef);\n      setRef((_f = this.props.startInputProps) === null || _f === void 0 ? void 0 : _f.inputRef, this.startInputElement);\n    }\n\n    if (((_g = prevProps.endInputProps) === null || _g === void 0 ? void 0 : _g.inputRef) !== ((_h = this.props.endInputProps) === null || _h === void 0 ? void 0 : _h.inputRef)) {\n      setRef((_j = prevProps.endInputProps) === null || _j === void 0 ? void 0 : _j.inputRef, null);\n      this.handleEndInputRef = refHandler(this, \"endInputElement\", (_k = this.props.endInputProps) === null || _k === void 0 ? void 0 : _k.inputRef);\n      setRef((_l = this.props.endInputProps) === null || _l === void 0 ? void 0 : _l.inputRef, this.endInputElement);\n    }\n\n    var shouldFocusStartInput = this.shouldFocusInputRef(isStartInputFocused, this.startInputElement);\n    var shouldFocusEndInput = this.shouldFocusInputRef(isEndInputFocused, this.endInputElement);\n\n    if (shouldFocusStartInput) {\n      (_m = this.startInputElement) === null || _m === void 0 ? void 0 : _m.focus();\n    } else if (shouldFocusEndInput) {\n      (_o = this.endInputElement) === null || _o === void 0 ? void 0 : _o.focus();\n    }\n\n    if (isStartInputFocused && shouldSelectAfterUpdate) {\n      (_p = this.startInputElement) === null || _p === void 0 ? void 0 : _p.select();\n    } else if (isEndInputFocused && shouldSelectAfterUpdate) {\n      (_q = this.endInputElement) === null || _q === void 0 ? void 0 : _q.select();\n    }\n\n    var nextState = {};\n\n    if (this.props.value !== prevProps.value) {\n      var _s = this.getInitialRange(this.props),\n          selectedStart = _s[0],\n          selectedEnd = _s[1];\n\n      nextState = __assign(__assign({}, nextState), {\n        selectedStart: selectedStart,\n        selectedEnd: selectedEnd\n      });\n    } // cache the formatted date strings to avoid computing on each render.\n\n\n    if (this.props.minDate !== prevProps.minDate) {\n      var formattedMinDateString = this.getFormattedMinMaxDateString(this.props, \"minDate\");\n      nextState = __assign(__assign({}, nextState), {\n        formattedMinDateString: formattedMinDateString\n      });\n    }\n\n    if (this.props.maxDate !== prevProps.maxDate) {\n      var formattedMaxDateString = this.getFormattedMinMaxDateString(this.props, \"maxDate\");\n      nextState = __assign(__assign({}, nextState), {\n        formattedMaxDateString: formattedMaxDateString\n      });\n    }\n\n    this.setState(nextState);\n  };\n\n  DateRangeInput.prototype.render = function () {\n    var selectedShortcutIndex = this.state.selectedShortcutIndex;\n    var _a = this.props.popoverProps,\n        popoverProps = _a === void 0 ? {} : _a;\n    var popoverContent = React.createElement(DateRangePicker, __assign({}, this.props, {\n      selectedShortcutIndex: selectedShortcutIndex,\n      boundaryToModify: this.state.boundaryToModify,\n      onChange: this.handleDateRangePickerChange,\n      onShortcutChange: this.handleShortcutChange,\n      onHoverChange: this.handleDateRangePickerHoverChange,\n      value: this.getSelectedRange()\n    }));\n    var popoverClassName = classNames(popoverProps.className, this.props.className); // allow custom props for the popover and each input group, but pass them in an order that\n    // guarantees only some props are overridable.\n\n    return (\n      /* eslint-disable-next-line deprecation/deprecation */\n      React.createElement(Popover, __assign({\n        isOpen: this.state.isOpen,\n        position: Position.BOTTOM_LEFT\n      }, this.props.popoverProps, {\n        autoFocus: false,\n        className: popoverClassName,\n        content: popoverContent,\n        enforceFocus: false,\n        onClose: this.handlePopoverClose\n      }), React.createElement(\"div\", {\n        className: Classes.CONTROL_GROUP\n      }, this.renderInputGroup(Boundary.START), this.renderInputGroup(Boundary.END)))\n    );\n  };\n\n  DateRangeInput.prototype.validateProps = function (props) {\n    if (props.value === null) {\n      throw new Error(Errors.DATERANGEINPUT_NULL_VALUE);\n    }\n  }; // Helpers\n  // =======\n\n\n  DateRangeInput.prototype.shouldFocusInputRef = function (isFocused, inputRef) {\n    return isFocused && inputRef !== undefined && document.activeElement !== inputRef;\n  };\n\n  DateRangeInput.prototype.isNextDateRangeValid = function (nextDate, boundary) {\n    return this.isDateValidAndInRange(nextDate) && !this.doBoundaryDatesOverlap(nextDate, boundary);\n  }; // this is a slightly kludgy function, but it saves us a good amount of repeated code between\n  // the constructor and componentDidUpdate.\n\n\n  DateRangeInput.prototype.getFormattedMinMaxDateString = function (props, propName) {\n    var date = props[propName];\n    var defaultDate = DateRangeInput_1.defaultProps[propName]; // default values are applied only if a prop is strictly `undefined`\n    // See: https://facebook.github.io/react/docs/react-component.html#defaultprops\n\n    return getFormattedDateString(date === undefined ? defaultDate : date, this.props);\n  };\n\n  DateRangeInput.prototype.parseDate = function (dateString) {\n    if (dateString === this.props.outOfRangeMessage || dateString === this.props.invalidDateMessage) {\n      return null;\n    }\n\n    var _a = this.props,\n        locale = _a.locale,\n        parseDate = _a.parseDate;\n    var newDate = parseDate(dateString, locale);\n    return newDate === false ? new Date(undefined) : newDate;\n  };\n\n  DateRangeInput.prototype.formatDate = function (date) {\n    if (!this.isDateValidAndInRange(date)) {\n      return \"\";\n    }\n\n    var _a = this.props,\n        locale = _a.locale,\n        formatDate = _a.formatDate;\n    return formatDate(date, locale);\n  };\n\n  var DateRangeInput_1;\n  DateRangeInput.defaultProps = {\n    allowSingleDayRange: false,\n    closeOnSelection: true,\n    contiguousCalendarMonths: true,\n    dayPickerProps: {},\n    disabled: false,\n    endInputProps: {},\n    invalidDateMessage: \"Invalid date\",\n    maxDate: getDefaultMaxDate(),\n    minDate: getDefaultMinDate(),\n    outOfRangeMessage: \"Out of range\",\n    overlappingDatesMessage: \"Overlapping dates\",\n    popoverProps: {},\n    selectAllOnFocus: false,\n    shortcuts: true,\n    singleMonthOnly: false,\n    startInputProps: {}\n  };\n  DateRangeInput.displayName = DISPLAYNAME_PREFIX + \".DateRangeInput\";\n  DateRangeInput = DateRangeInput_1 = __decorate([polyfill], DateRangeInput);\n  return DateRangeInput;\n}(AbstractPureComponent2);\n\nexport { DateRangeInput };","map":{"version":3,"sources":["../../src/dateRangeInput.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport DayPicker from \"react-day-picker\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Boundary, Classes, DISPLAYNAME_PREFIX, InputGroup, Intent, Keys, Popover, Position, refHandler, setRef, } from \"@blueprintjs/core\";\nimport { areSameTime, isDateValid, isDayInRange } from \"./common/dateUtils\";\nimport * as Errors from \"./common/errors\";\nimport { getFormattedDateString } from \"./dateFormat\";\nimport { getDefaultMaxDate, getDefaultMinDate } from \"./datePickerCore\";\nimport { DateRangePicker } from \"./dateRangePicker\";\nvar DateRangeInput = /** @class */ (function (_super) {\n    __extends(DateRangeInput, _super);\n    function DateRangeInput(props, context) {\n        var _a, _b;\n        var _this = _super.call(this, props, context) || this;\n        _this.startInputElement = null;\n        _this.endInputElement = null;\n        _this.handleStartInputRef = refHandler(_this, \"startInputElement\", (_a = _this.props.startInputProps) === null || _a === void 0 ? void 0 : _a.inputRef);\n        _this.handleEndInputRef = refHandler(_this, \"endInputElement\", (_b = _this.props.endInputProps) === null || _b === void 0 ? void 0 : _b.inputRef);\n        _this.renderInputGroup = function (boundary) {\n            var inputProps = _this.getInputProps(boundary);\n            var handleInputEvent = boundary === Boundary.START ? _this.handleStartInputEvent : _this.handleEndInputEvent;\n            return (React.createElement(InputGroup, __assign({ autoComplete: \"off\", disabled: inputProps.disabled || _this.props.disabled }, inputProps, { intent: _this.isInputInErrorState(boundary) ? Intent.DANGER : inputProps.intent, inputRef: _this.getInputRef(boundary), onBlur: handleInputEvent, onChange: handleInputEvent, onClick: handleInputEvent, onFocus: handleInputEvent, onKeyDown: handleInputEvent, onMouseDown: handleInputEvent, placeholder: _this.getInputPlaceholderString(boundary), value: _this.getInputDisplayString(boundary) })));\n        };\n        // Callbacks - DateRangePicker\n        // ===========================\n        _this.handleDateRangePickerChange = function (selectedRange, didSubmitWithEnter) {\n            var _a, _b;\n            if (didSubmitWithEnter === void 0) { didSubmitWithEnter = false; }\n            // ignore mouse events in the date-range picker if the popover is animating closed.\n            if (!_this.state.isOpen) {\n                return;\n            }\n            var selectedStart = selectedRange[0], selectedEnd = selectedRange[1];\n            var isOpen = true;\n            var isStartInputFocused;\n            var isEndInputFocused;\n            var startHoverString;\n            var endHoverString;\n            var boundaryToModify;\n            if (selectedStart == null) {\n                // focus the start field by default or if only an end date is specified\n                if (_this.props.timePrecision == null) {\n                    isStartInputFocused = true;\n                    isEndInputFocused = false;\n                }\n                else {\n                    isStartInputFocused = false;\n                    isEndInputFocused = false;\n                    boundaryToModify = Boundary.START;\n                }\n                // for clarity, hide the hover string until the mouse moves over a different date\n                startHoverString = null;\n            }\n            else if (selectedEnd == null) {\n                // focus the end field if a start date is specified\n                if (_this.props.timePrecision == null) {\n                    isStartInputFocused = false;\n                    isEndInputFocused = true;\n                }\n                else {\n                    isStartInputFocused = false;\n                    isEndInputFocused = false;\n                    boundaryToModify = Boundary.END;\n                }\n                endHoverString = null;\n            }\n            else if (_this.props.closeOnSelection) {\n                isOpen = _this.getIsOpenValueWhenDateChanges(selectedStart, selectedEnd);\n                isStartInputFocused = false;\n                if (_this.props.timePrecision == null && didSubmitWithEnter) {\n                    // if we submit via click or Tab, the focus will have moved already.\n                    // it we submit with Enter, the focus won't have moved, and setting\n                    // the flag to false won't have an effect anyway, so leave it true.\n                    isEndInputFocused = true;\n                }\n                else {\n                    isEndInputFocused = false;\n                    boundaryToModify = Boundary.END;\n                }\n            }\n            else if (_this.state.lastFocusedField === Boundary.START) {\n                // keep the start field focused\n                if (_this.props.timePrecision == null) {\n                    isStartInputFocused = true;\n                    isEndInputFocused = false;\n                }\n                else {\n                    isStartInputFocused = false;\n                    isEndInputFocused = false;\n                    boundaryToModify = Boundary.START;\n                }\n            }\n            else if (_this.props.timePrecision == null) {\n                // keep the end field focused\n                isStartInputFocused = false;\n                isEndInputFocused = true;\n            }\n            else {\n                isStartInputFocused = false;\n                isEndInputFocused = false;\n                boundaryToModify = Boundary.END;\n            }\n            var baseStateChange = {\n                boundaryToModify: boundaryToModify,\n                endHoverString: endHoverString,\n                endInputString: _this.formatDate(selectedEnd),\n                isEndInputFocused: isEndInputFocused,\n                isOpen: isOpen,\n                isStartInputFocused: isStartInputFocused,\n                startHoverString: startHoverString,\n                startInputString: _this.formatDate(selectedStart),\n                wasLastFocusChangeDueToHover: false,\n            };\n            if (_this.isControlled()) {\n                _this.setState(baseStateChange);\n            }\n            else {\n                _this.setState(__assign(__assign({}, baseStateChange), { selectedEnd: selectedEnd, selectedStart: selectedStart }));\n            }\n            (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, selectedRange);\n        };\n        _this.handleShortcutChange = function (_, selectedShortcutIndex) {\n            _this.setState({ selectedShortcutIndex: selectedShortcutIndex });\n        };\n        _this.handleDateRangePickerHoverChange = function (hoveredRange, _hoveredDay, hoveredBoundary) {\n            // ignore mouse events in the date-range picker if the popover is animating closed.\n            if (!_this.state.isOpen) {\n                return;\n            }\n            if (hoveredRange == null) {\n                // undo whatever focus changes we made while hovering over various calendar dates\n                var isEndInputFocused = _this.state.boundaryToModify === Boundary.END;\n                _this.setState({\n                    endHoverString: null,\n                    isEndInputFocused: isEndInputFocused,\n                    isStartInputFocused: !isEndInputFocused,\n                    lastFocusedField: _this.state.boundaryToModify,\n                    startHoverString: null,\n                });\n            }\n            else {\n                var hoveredStart = hoveredRange[0], hoveredEnd = hoveredRange[1];\n                var isStartInputFocused = hoveredBoundary != null ? hoveredBoundary === Boundary.START : _this.state.isStartInputFocused;\n                var isEndInputFocused = hoveredBoundary != null ? hoveredBoundary === Boundary.END : _this.state.isEndInputFocused;\n                _this.setState({\n                    endHoverString: _this.formatDate(hoveredEnd),\n                    isEndInputFocused: isEndInputFocused,\n                    isStartInputFocused: isStartInputFocused,\n                    lastFocusedField: isStartInputFocused ? Boundary.START : Boundary.END,\n                    shouldSelectAfterUpdate: _this.props.selectAllOnFocus,\n                    startHoverString: _this.formatDate(hoveredStart),\n                    wasLastFocusChangeDueToHover: true,\n                });\n            }\n        };\n        // Callbacks - Input\n        // =================\n        // instantiate these two functions once so we don't have to for each callback on each render.\n        _this.handleStartInputEvent = function (e) {\n            _this.handleInputEvent(e, Boundary.START);\n        };\n        _this.handleEndInputEvent = function (e) {\n            _this.handleInputEvent(e, Boundary.END);\n        };\n        _this.handleInputEvent = function (e, boundary) {\n            var _a, _b, _c, _d, _f, _g;\n            var inputProps = _this.getInputProps(boundary);\n            switch (e.type) {\n                case \"blur\":\n                    _this.handleInputBlur(e, boundary);\n                    (_a = inputProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(inputProps, e);\n                    break;\n                case \"change\":\n                    _this.handleInputChange(e, boundary);\n                    (_b = inputProps.onChange) === null || _b === void 0 ? void 0 : _b.call(inputProps, e);\n                    break;\n                case \"click\":\n                    e = e;\n                    _this.handleInputClick(e);\n                    (_c = inputProps.onClick) === null || _c === void 0 ? void 0 : _c.call(inputProps, e);\n                    break;\n                case \"focus\":\n                    _this.handleInputFocus(e, boundary);\n                    (_d = inputProps.onFocus) === null || _d === void 0 ? void 0 : _d.call(inputProps, e);\n                    break;\n                case \"keydown\":\n                    e = e;\n                    _this.handleInputKeyDown(e);\n                    (_f = inputProps.onKeyDown) === null || _f === void 0 ? void 0 : _f.call(inputProps, e);\n                    break;\n                case \"mousedown\":\n                    e = e;\n                    _this.handleInputMouseDown();\n                    (_g = inputProps.onMouseDown) === null || _g === void 0 ? void 0 : _g.call(inputProps, e);\n                    break;\n                default:\n                    break;\n            }\n        };\n        // add a keydown listener to persistently change focus when tabbing:\n        // - if focused in start field, Tab moves focus to end field\n        // - if focused in end field, Shift+Tab moves focus to start field\n        _this.handleInputKeyDown = function (e) {\n            // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n            /* eslint-disable deprecation/deprecation */\n            var isTabPressed = e.which === Keys.TAB;\n            var isEnterPressed = e.which === Keys.ENTER;\n            var isShiftPressed = e.shiftKey;\n            var _a = _this.state, selectedStart = _a.selectedStart, selectedEnd = _a.selectedEnd;\n            // order of JS events is our enemy here. when tabbing between fields,\n            // this handler will fire in the middle of a focus exchange when no\n            // field is currently focused. we work around this by referring to the\n            // most recently focused field, rather than the currently focused field.\n            var wasStartFieldFocused = _this.state.lastFocusedField === Boundary.START;\n            var wasEndFieldFocused = _this.state.lastFocusedField === Boundary.END;\n            // move focus to the other field\n            if (isTabPressed) {\n                var isEndInputFocused = void 0;\n                var isStartInputFocused = void 0;\n                var isOpen = true;\n                if (wasStartFieldFocused && !isShiftPressed) {\n                    isStartInputFocused = false;\n                    isEndInputFocused = true;\n                    // prevent the default focus-change behavior to avoid race conditions;\n                    // we'll handle the focus change ourselves in componentDidUpdate.\n                    e.preventDefault();\n                }\n                else if (wasEndFieldFocused && isShiftPressed) {\n                    isStartInputFocused = true;\n                    isEndInputFocused = false;\n                    e.preventDefault();\n                }\n                else {\n                    // don't prevent default here, otherwise Tab won't do anything.\n                    isStartInputFocused = false;\n                    isEndInputFocused = false;\n                    isOpen = false;\n                }\n                _this.setState({\n                    isEndInputFocused: isEndInputFocused,\n                    isOpen: isOpen,\n                    isStartInputFocused: isStartInputFocused,\n                    wasLastFocusChangeDueToHover: false,\n                });\n            }\n            else if (wasStartFieldFocused && isEnterPressed) {\n                var nextStartDate = _this.parseDate(_this.state.startInputString);\n                _this.handleDateRangePickerChange([nextStartDate, selectedEnd], true);\n            }\n            else if (wasEndFieldFocused && isEnterPressed) {\n                var nextEndDate = _this.parseDate(_this.state.endInputString);\n                _this.handleDateRangePickerChange([selectedStart, nextEndDate], true);\n            }\n            else {\n                // let the default keystroke happen without side effects\n                return;\n            }\n        };\n        _this.handleInputMouseDown = function () {\n            // clicking in the field constitutes an explicit focus change. we update\n            // the flag on \"mousedown\" instead of on \"click\", because it needs to be\n            // set before onFocus is called (\"click\" triggers after \"focus\").\n            _this.setState({ wasLastFocusChangeDueToHover: false });\n        };\n        _this.handleInputClick = function (e) {\n            // unless we stop propagation on this event, a click within an input\n            // will close the popover almost as soon as it opens.\n            e.stopPropagation();\n        };\n        _this.handleInputFocus = function (_e, boundary) {\n            var _a;\n            var _b = _this.getStateKeysAndValuesForBoundary(boundary), keys = _b.keys, values = _b.values;\n            var inputString = getFormattedDateString(values.selectedValue, _this.props, true);\n            // change the boundary only if the user explicitly focused in the field.\n            // focus changes from hovering don't count; they're just temporary.\n            var boundaryToModify = _this.state.wasLastFocusChangeDueToHover ? _this.state.boundaryToModify : boundary;\n            _this.setState((_a = {},\n                _a[keys.inputString] = inputString,\n                _a[keys.isInputFocused] = true,\n                _a.boundaryToModify = boundaryToModify,\n                _a.isOpen = true,\n                _a.lastFocusedField = boundary,\n                _a.shouldSelectAfterUpdate = _this.props.selectAllOnFocus,\n                _a.wasLastFocusChangeDueToHover = false,\n                _a));\n        };\n        _this.handleInputBlur = function (_e, boundary) {\n            var _a, _b, _c, _d;\n            var _f, _g;\n            var _h = _this.getStateKeysAndValuesForBoundary(boundary), keys = _h.keys, values = _h.values;\n            var maybeNextDate = _this.parseDate(values.inputString);\n            var isValueControlled = _this.isControlled();\n            var nextState = (_a = {},\n                _a[keys.isInputFocused] = false,\n                _a.shouldSelectAfterUpdate = false,\n                _a);\n            if (_this.isInputEmpty(values.inputString)) {\n                if (isValueControlled) {\n                    nextState = __assign(__assign({}, nextState), (_b = {}, _b[keys.inputString] = getFormattedDateString(values.controlledValue, _this.props), _b));\n                }\n                else {\n                    nextState = __assign(__assign({}, nextState), (_c = {}, _c[keys.inputString] = null, _c[keys.selectedValue] = null, _c));\n                }\n            }\n            else if (!_this.isNextDateRangeValid(maybeNextDate, boundary)) {\n                if (!isValueControlled) {\n                    nextState = __assign(__assign({}, nextState), (_d = {}, _d[keys.inputString] = null, _d[keys.selectedValue] = maybeNextDate, _d));\n                }\n                (_g = (_f = _this.props).onError) === null || _g === void 0 ? void 0 : _g.call(_f, _this.getDateRangeForCallback(maybeNextDate, boundary));\n            }\n            _this.setState(nextState);\n        };\n        _this.handleInputChange = function (e, boundary) {\n            var _a, _b, _c, _d, _f;\n            var _g, _h, _j, _k;\n            var inputString = e.target.value;\n            var keys = _this.getStateKeysAndValuesForBoundary(boundary).keys;\n            var maybeNextDate = _this.parseDate(inputString);\n            var isValueControlled = _this.isControlled();\n            var nextState = { shouldSelectAfterUpdate: false };\n            if (inputString.length === 0) {\n                // this case will be relevant when we start showing the hovered range in the input\n                // fields. goal is to show an empty field for clarity until the mouse moves over a\n                // different date.\n                var baseState = __assign(__assign({}, nextState), (_a = {}, _a[keys.inputString] = \"\", _a));\n                if (isValueControlled) {\n                    nextState = baseState;\n                }\n                else {\n                    nextState = __assign(__assign({}, baseState), (_b = {}, _b[keys.selectedValue] = null, _b));\n                }\n                (_h = (_g = _this.props).onChange) === null || _h === void 0 ? void 0 : _h.call(_g, _this.getDateRangeForCallback(null, boundary));\n            }\n            else if (_this.isDateValidAndInRange(maybeNextDate)) {\n                // note that error cases that depend on both fields (e.g. overlapping dates) should fall\n                // through into this block so that the UI can update immediately, possibly with an error\n                // message on the other field.\n                // also, clear the hover string to ensure the most recent keystroke appears.\n                var baseState = __assign(__assign({}, nextState), (_c = {}, _c[keys.hoverString] = null, _c[keys.inputString] = inputString, _c));\n                if (isValueControlled) {\n                    nextState = baseState;\n                }\n                else {\n                    nextState = __assign(__assign({}, baseState), (_d = {}, _d[keys.selectedValue] = maybeNextDate, _d));\n                }\n                if (_this.isNextDateRangeValid(maybeNextDate, boundary)) {\n                    (_k = (_j = _this.props).onChange) === null || _k === void 0 ? void 0 : _k.call(_j, _this.getDateRangeForCallback(maybeNextDate, boundary));\n                }\n            }\n            else {\n                // again, clear the hover string to ensure the most recent keystroke appears\n                nextState = __assign(__assign({}, nextState), (_f = {}, _f[keys.inputString] = inputString, _f[keys.hoverString] = null, _f));\n            }\n            _this.setState(nextState);\n        };\n        // Callbacks - Popover\n        // ===================\n        _this.handlePopoverClose = function (event) {\n            var _a, _b;\n            _this.setState({ isOpen: false });\n            (_b = (_a = _this.props.popoverProps).onClose) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n        };\n        _this.getIsOpenValueWhenDateChanges = function (nextSelectedStart, nextSelectedEnd) {\n            if (_this.props.closeOnSelection) {\n                // trivial case when TimePicker is not shown\n                if (_this.props.timePrecision == null) {\n                    return false;\n                }\n                var fallbackDate = new Date(new Date().setHours(0, 0, 0, 0));\n                var _a = _this.getSelectedRange([fallbackDate, fallbackDate]), selectedStart = _a[0], selectedEnd = _a[1];\n                // case to check if the user has changed TimePicker values\n                if (areSameTime(selectedStart, nextSelectedStart) === true &&\n                    areSameTime(selectedEnd, nextSelectedEnd) === true) {\n                    return false;\n                }\n                return true;\n            }\n            return true;\n        };\n        _this.getInitialRange = function (props) {\n            if (props === void 0) { props = _this.props; }\n            var defaultValue = props.defaultValue, value = props.value;\n            if (value != null) {\n                return value;\n            }\n            else if (defaultValue != null) {\n                return defaultValue;\n            }\n            else {\n                return [null, null];\n            }\n        };\n        _this.getSelectedRange = function (fallbackRange) {\n            var _a;\n            var selectedStart;\n            var selectedEnd;\n            if (_this.isControlled()) {\n                _a = _this.props.value, selectedStart = _a[0], selectedEnd = _a[1];\n            }\n            else {\n                selectedStart = _this.state.selectedStart;\n                selectedEnd = _this.state.selectedEnd;\n            }\n            // this helper function checks if the provided boundary date *would* overlap the selected\n            // other boundary date. providing the already-selected start date simply tells us if we're\n            // currently in an overlapping state.\n            var doBoundaryDatesOverlap = _this.doBoundaryDatesOverlap(selectedStart, Boundary.START);\n            var dateRange = [selectedStart, doBoundaryDatesOverlap ? undefined : selectedEnd];\n            return dateRange.map(function (selectedBound, index) {\n                var fallbackDate = fallbackRange != null ? fallbackRange[index] : undefined;\n                return _this.isDateValidAndInRange(selectedBound) ? selectedBound : fallbackDate;\n            });\n        };\n        _this.getInputDisplayString = function (boundary) {\n            var values = _this.getStateKeysAndValuesForBoundary(boundary).values;\n            var isInputFocused = values.isInputFocused, inputString = values.inputString, selectedValue = values.selectedValue, hoverString = values.hoverString;\n            if (hoverString != null) {\n                return hoverString;\n            }\n            else if (isInputFocused) {\n                return inputString == null ? \"\" : inputString;\n            }\n            else if (selectedValue == null) {\n                return \"\";\n            }\n            else if (_this.doesEndBoundaryOverlapStartBoundary(selectedValue, boundary)) {\n                return _this.props.overlappingDatesMessage;\n            }\n            else {\n                return getFormattedDateString(selectedValue, _this.props);\n            }\n        };\n        _this.getInputPlaceholderString = function (boundary) {\n            var isStartBoundary = boundary === Boundary.START;\n            var isEndBoundary = boundary === Boundary.END;\n            var inputProps = _this.getInputProps(boundary);\n            var isInputFocused = _this.getStateKeysAndValuesForBoundary(boundary).values.isInputFocused;\n            // use the custom placeholder text for the input, if providied\n            if (inputProps.placeholder != null) {\n                return inputProps.placeholder;\n            }\n            else if (isStartBoundary) {\n                return isInputFocused ? _this.state.formattedMinDateString : \"Start date\";\n            }\n            else if (isEndBoundary) {\n                return isInputFocused ? _this.state.formattedMaxDateString : \"End date\";\n            }\n            else {\n                return \"\";\n            }\n        };\n        _this.getInputProps = function (boundary) {\n            return boundary === Boundary.START ? _this.props.startInputProps : _this.props.endInputProps;\n        };\n        _this.getInputRef = function (boundary) {\n            return boundary === Boundary.START ? _this.handleStartInputRef : _this.handleEndInputRef;\n        };\n        _this.getStateKeysAndValuesForBoundary = function (boundary) {\n            var controlledRange = _this.props.value;\n            if (boundary === Boundary.START) {\n                return {\n                    keys: {\n                        hoverString: \"startHoverString\",\n                        inputString: \"startInputString\",\n                        isInputFocused: \"isStartInputFocused\",\n                        selectedValue: \"selectedStart\",\n                    },\n                    values: {\n                        controlledValue: controlledRange != null ? controlledRange[0] : undefined,\n                        hoverString: _this.state.startHoverString,\n                        inputString: _this.state.startInputString,\n                        isInputFocused: _this.state.isStartInputFocused,\n                        selectedValue: _this.state.selectedStart,\n                    },\n                };\n            }\n            else {\n                return {\n                    keys: {\n                        hoverString: \"endHoverString\",\n                        inputString: \"endInputString\",\n                        isInputFocused: \"isEndInputFocused\",\n                        selectedValue: \"selectedEnd\",\n                    },\n                    values: {\n                        controlledValue: controlledRange != null ? controlledRange[1] : undefined,\n                        hoverString: _this.state.endHoverString,\n                        inputString: _this.state.endInputString,\n                        isInputFocused: _this.state.isEndInputFocused,\n                        selectedValue: _this.state.selectedEnd,\n                    },\n                };\n            }\n        };\n        _this.getDateRangeForCallback = function (currDate, currBoundary) {\n            var otherBoundary = _this.getOtherBoundary(currBoundary);\n            var otherDate = _this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n            return currBoundary === Boundary.START ? [currDate, otherDate] : [otherDate, currDate];\n        };\n        _this.getOtherBoundary = function (boundary) {\n            return boundary === Boundary.START ? Boundary.END : Boundary.START;\n        };\n        _this.doBoundaryDatesOverlap = function (date, boundary) {\n            var allowSingleDayRange = _this.props.allowSingleDayRange;\n            var otherBoundary = _this.getOtherBoundary(boundary);\n            var otherBoundaryDate = _this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n            if (date == null || otherBoundaryDate == null) {\n                return false;\n            }\n            if (boundary === Boundary.START) {\n                var isAfter = date > otherBoundaryDate;\n                return isAfter || (!allowSingleDayRange && DayPicker.DateUtils.isSameDay(date, otherBoundaryDate));\n            }\n            else {\n                var isBefore = date < otherBoundaryDate;\n                return isBefore || (!allowSingleDayRange && DayPicker.DateUtils.isSameDay(date, otherBoundaryDate));\n            }\n        };\n        /**\n         * Returns true if the provided boundary is an END boundary overlapping the\n         * selected start date. (If the boundaries overlap, we consider the END\n         * boundary to be erroneous.)\n         */\n        _this.doesEndBoundaryOverlapStartBoundary = function (boundaryDate, boundary) {\n            return boundary === Boundary.START ? false : _this.doBoundaryDatesOverlap(boundaryDate, boundary);\n        };\n        _this.isControlled = function () { return _this.props.value !== undefined; };\n        _this.isInputEmpty = function (inputString) { return inputString == null || inputString.length === 0; };\n        _this.isInputInErrorState = function (boundary) {\n            var values = _this.getStateKeysAndValuesForBoundary(boundary).values;\n            var isInputFocused = values.isInputFocused, hoverString = values.hoverString, inputString = values.inputString, selectedValue = values.selectedValue;\n            if (hoverString != null || _this.isInputEmpty(inputString)) {\n                // don't show an error state while we're hovering over a valid date.\n                return false;\n            }\n            var boundaryValue = isInputFocused ? _this.parseDate(inputString) : selectedValue;\n            return (boundaryValue != null &&\n                (!_this.isDateValidAndInRange(boundaryValue) ||\n                    _this.doesEndBoundaryOverlapStartBoundary(boundaryValue, boundary)));\n        };\n        _this.isDateValidAndInRange = function (date) {\n            return isDateValid(date) && isDayInRange(date, [_this.props.minDate, _this.props.maxDate]);\n        };\n        _this.reset(props);\n        return _this;\n    }\n    DateRangeInput_1 = DateRangeInput;\n    /**\n     * Public method intended for unit testing only. Do not use in feature work!\n     */\n    DateRangeInput.prototype.reset = function (props) {\n        if (props === void 0) { props = this.props; }\n        var _a = this.getInitialRange(), selectedStart = _a[0], selectedEnd = _a[1];\n        this.state = {\n            formattedMaxDateString: this.getFormattedMinMaxDateString(props, \"maxDate\"),\n            formattedMinDateString: this.getFormattedMinMaxDateString(props, \"minDate\"),\n            isOpen: false,\n            selectedEnd: selectedEnd,\n            selectedShortcutIndex: -1,\n            selectedStart: selectedStart,\n        };\n    };\n    DateRangeInput.prototype.componentDidUpdate = function (prevProps, prevState) {\n        var _a, _b, _c, _d, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n        _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n        var _r = this.state, isStartInputFocused = _r.isStartInputFocused, isEndInputFocused = _r.isEndInputFocused, shouldSelectAfterUpdate = _r.shouldSelectAfterUpdate;\n        if (((_a = prevProps.startInputProps) === null || _a === void 0 ? void 0 : _a.inputRef) !== ((_b = this.props.startInputProps) === null || _b === void 0 ? void 0 : _b.inputRef)) {\n            setRef((_c = prevProps.startInputProps) === null || _c === void 0 ? void 0 : _c.inputRef, null);\n            this.handleStartInputRef = refHandler(this, \"startInputElement\", (_d = this.props.startInputProps) === null || _d === void 0 ? void 0 : _d.inputRef);\n            setRef((_f = this.props.startInputProps) === null || _f === void 0 ? void 0 : _f.inputRef, this.startInputElement);\n        }\n        if (((_g = prevProps.endInputProps) === null || _g === void 0 ? void 0 : _g.inputRef) !== ((_h = this.props.endInputProps) === null || _h === void 0 ? void 0 : _h.inputRef)) {\n            setRef((_j = prevProps.endInputProps) === null || _j === void 0 ? void 0 : _j.inputRef, null);\n            this.handleEndInputRef = refHandler(this, \"endInputElement\", (_k = this.props.endInputProps) === null || _k === void 0 ? void 0 : _k.inputRef);\n            setRef((_l = this.props.endInputProps) === null || _l === void 0 ? void 0 : _l.inputRef, this.endInputElement);\n        }\n        var shouldFocusStartInput = this.shouldFocusInputRef(isStartInputFocused, this.startInputElement);\n        var shouldFocusEndInput = this.shouldFocusInputRef(isEndInputFocused, this.endInputElement);\n        if (shouldFocusStartInput) {\n            (_m = this.startInputElement) === null || _m === void 0 ? void 0 : _m.focus();\n        }\n        else if (shouldFocusEndInput) {\n            (_o = this.endInputElement) === null || _o === void 0 ? void 0 : _o.focus();\n        }\n        if (isStartInputFocused && shouldSelectAfterUpdate) {\n            (_p = this.startInputElement) === null || _p === void 0 ? void 0 : _p.select();\n        }\n        else if (isEndInputFocused && shouldSelectAfterUpdate) {\n            (_q = this.endInputElement) === null || _q === void 0 ? void 0 : _q.select();\n        }\n        var nextState = {};\n        if (this.props.value !== prevProps.value) {\n            var _s = this.getInitialRange(this.props), selectedStart = _s[0], selectedEnd = _s[1];\n            nextState = __assign(__assign({}, nextState), { selectedStart: selectedStart, selectedEnd: selectedEnd });\n        }\n        // cache the formatted date strings to avoid computing on each render.\n        if (this.props.minDate !== prevProps.minDate) {\n            var formattedMinDateString = this.getFormattedMinMaxDateString(this.props, \"minDate\");\n            nextState = __assign(__assign({}, nextState), { formattedMinDateString: formattedMinDateString });\n        }\n        if (this.props.maxDate !== prevProps.maxDate) {\n            var formattedMaxDateString = this.getFormattedMinMaxDateString(this.props, \"maxDate\");\n            nextState = __assign(__assign({}, nextState), { formattedMaxDateString: formattedMaxDateString });\n        }\n        this.setState(nextState);\n    };\n    DateRangeInput.prototype.render = function () {\n        var selectedShortcutIndex = this.state.selectedShortcutIndex;\n        var _a = this.props.popoverProps, popoverProps = _a === void 0 ? {} : _a;\n        var popoverContent = (React.createElement(DateRangePicker, __assign({}, this.props, { selectedShortcutIndex: selectedShortcutIndex, boundaryToModify: this.state.boundaryToModify, onChange: this.handleDateRangePickerChange, onShortcutChange: this.handleShortcutChange, onHoverChange: this.handleDateRangePickerHoverChange, value: this.getSelectedRange() })));\n        var popoverClassName = classNames(popoverProps.className, this.props.className);\n        // allow custom props for the popover and each input group, but pass them in an order that\n        // guarantees only some props are overridable.\n        return (\n        /* eslint-disable-next-line deprecation/deprecation */\n        React.createElement(Popover, __assign({ isOpen: this.state.isOpen, position: Position.BOTTOM_LEFT }, this.props.popoverProps, { autoFocus: false, className: popoverClassName, content: popoverContent, enforceFocus: false, onClose: this.handlePopoverClose }),\n            React.createElement(\"div\", { className: Classes.CONTROL_GROUP },\n                this.renderInputGroup(Boundary.START),\n                this.renderInputGroup(Boundary.END))));\n    };\n    DateRangeInput.prototype.validateProps = function (props) {\n        if (props.value === null) {\n            throw new Error(Errors.DATERANGEINPUT_NULL_VALUE);\n        }\n    };\n    // Helpers\n    // =======\n    DateRangeInput.prototype.shouldFocusInputRef = function (isFocused, inputRef) {\n        return isFocused && inputRef !== undefined && document.activeElement !== inputRef;\n    };\n    DateRangeInput.prototype.isNextDateRangeValid = function (nextDate, boundary) {\n        return this.isDateValidAndInRange(nextDate) && !this.doBoundaryDatesOverlap(nextDate, boundary);\n    };\n    // this is a slightly kludgy function, but it saves us a good amount of repeated code between\n    // the constructor and componentDidUpdate.\n    DateRangeInput.prototype.getFormattedMinMaxDateString = function (props, propName) {\n        var date = props[propName];\n        var defaultDate = DateRangeInput_1.defaultProps[propName];\n        // default values are applied only if a prop is strictly `undefined`\n        // See: https://facebook.github.io/react/docs/react-component.html#defaultprops\n        return getFormattedDateString(date === undefined ? defaultDate : date, this.props);\n    };\n    DateRangeInput.prototype.parseDate = function (dateString) {\n        if (dateString === this.props.outOfRangeMessage || dateString === this.props.invalidDateMessage) {\n            return null;\n        }\n        var _a = this.props, locale = _a.locale, parseDate = _a.parseDate;\n        var newDate = parseDate(dateString, locale);\n        return newDate === false ? new Date(undefined) : newDate;\n    };\n    DateRangeInput.prototype.formatDate = function (date) {\n        if (!this.isDateValidAndInRange(date)) {\n            return \"\";\n        }\n        var _a = this.props, locale = _a.locale, formatDate = _a.formatDate;\n        return formatDate(date, locale);\n    };\n    var DateRangeInput_1;\n    DateRangeInput.defaultProps = {\n        allowSingleDayRange: false,\n        closeOnSelection: true,\n        contiguousCalendarMonths: true,\n        dayPickerProps: {},\n        disabled: false,\n        endInputProps: {},\n        invalidDateMessage: \"Invalid date\",\n        maxDate: getDefaultMaxDate(),\n        minDate: getDefaultMinDate(),\n        outOfRangeMessage: \"Out of range\",\n        overlappingDatesMessage: \"Overlapping dates\",\n        popoverProps: {},\n        selectAllOnFocus: false,\n        shortcuts: true,\n        singleMonthOnly: false,\n        startInputProps: {},\n    };\n    DateRangeInput.displayName = DISPLAYNAME_PREFIX + \".DateRangeInput\";\n    DateRangeInput = DateRangeInput_1 = __decorate([\n        polyfill\n    ], DateRangeInput);\n    return DateRangeInput;\n}(AbstractPureComponent2));\nexport { DateRangeInput };\n//# sourceMappingURL=dateRangeInput.js.map"]},"metadata":{},"sourceType":"module"}