{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes as CoreClasses, DISPLAYNAME_PREFIX, Keys, refHandler, mergeRefs, Overlay, Utils } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport * as Errors from \"./errors\";\nimport { POPOVER_ARROW_SVG_SIZE, Popover2Arrow } from \"./popover2Arrow\";\nimport { positionToPlacement } from \"./popover2PlacementUtils\";\nimport { ResizeSensor2 } from \"./resizeSensor2\"; // eslint-disable-next-line import/no-cycle\n\nimport { Tooltip2 } from \"./tooltip2\";\nimport { getBasePlacement, getTransformOrigin } from \"./utils\";\nexport var Popover2InteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/**\n * @template T target component props inteface\n */\n\nvar Popover2 =\n/** @class */\nfunction (_super) {\n  __extends(Popover2, _super);\n\n  function Popover2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      hasDarkParent: false,\n      isOpen: _this.getIsOpen(_this.props)\n    };\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n\n    _this.popoverElement = null;\n    /** DOM element that contains the target. */\n\n    _this.targetElement = null;\n    /** Popover ref handler */\n\n    _this.popoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n    /** Target ref handler */\n\n    _this.targetRef = function (el) {\n      return _this.targetElement = el;\n    }; // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n\n\n    _this.isMouseInTargetOrPopover = false; // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n\n    _this.lostFocusOnSamePage = true;\n\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    }; // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n\n\n    _this.isArrowEnabled = function () {\n      var _a, _b;\n\n      return !_this.props.minimal && ((_b = (_a = _this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false;\n    };\n\n    _this.isHoverInteractionKind = function () {\n      return _this.props.interactionKind === Popover2InteractionKind.HOVER || _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n\n\n    _this.reposition = function () {\n      var _a;\n\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n\n    _this.renderTarget = function (_a) {\n      var _b, _c;\n\n      var _d;\n\n      var popperChildRef = _a.ref;\n      var _e = _this.props,\n          children = _e.children,\n          className = _e.className,\n          fill = _e.fill,\n          openOnTargetFocus = _e.openOnTargetFocus,\n          renderTarget = _e.renderTarget;\n      var isOpen = _this.state.isOpen;\n\n      var isControlled = _this.isControlled();\n\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n\n      var targetTagName = _this.props.targetTagName;\n\n      if (fill) {\n        targetTagName = \"div\";\n      }\n\n      var ref = mergeRefs(popperChildRef, _this.targetRef);\n      var targetEventHandlers = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onContextMenu: _this.handleTargetContextMenu,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick,\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        onKeyDown: function (event) {\n          // eslint-disable-next-line deprecation/deprecation\n          return Keys.isKeyboardClick(event.keyCode) && _this.handleTargetClick(event);\n        }\n      }; // Ensure target is focusable if relevant prop enabled\n\n      var targetTabIndex = openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n\n      var targetProps = __assign({\n        \"aria-haspopup\": \"true\",\n        // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n        // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n        // applied to the generated target wrapper element.\n        className: classNames(className, Classes.POPOVER2_TARGET, (_b = {}, _b[Classes.POPOVER2_OPEN] = isOpen, // this class is mainly useful for button targets\n        _b[CoreClasses.ACTIVE] = !isControlled && isOpen && !isHoverInteractionKind, _b)),\n        ref: ref\n      }, targetEventHandlers);\n\n      var target;\n\n      if (renderTarget !== undefined) {\n        target = renderTarget(__assign(__assign({}, targetProps), {\n          // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n          // when *this* popover is open\n          isOpen: isOpen,\n          tabIndex: targetTabIndex\n        }));\n      } else {\n        var childTarget = Utils.ensureElement(React.Children.toArray(children)[0]);\n\n        if (childTarget === undefined) {\n          return null;\n        }\n\n        var targetModifierClasses = (_c = {}, // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n        // uncontrolled popovers when they are opened by a user interaction\n        _c[CoreClasses.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n        _c[CoreClasses.FILL] = fill, _c);\n        var clonedTarget = React.cloneElement(childTarget, {\n          className: classNames(childTarget.props.className, targetModifierClasses),\n          // force disable single Tooltip2 child when popover is open\n          disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip2) ? true : childTarget.props.disabled,\n          tabIndex: (_d = childTarget.props.tabIndex) !== null && _d !== void 0 ? _d : targetTabIndex\n        });\n        var wrappedTarget = React.createElement(targetTagName, targetProps, clonedTarget);\n        target = wrappedTarget;\n      }\n\n      return React.createElement(ResizeSensor2, {\n        targetRef: ref,\n        onResize: _this.reposition\n      }, target);\n    };\n\n    _this.renderPopover = function (popperProps) {\n      var _a;\n\n      var _b;\n\n      var _c = _this.props,\n          interactionKind = _c.interactionKind,\n          shouldReturnFocusOnClose = _c.shouldReturnFocusOnClose,\n          usePortal = _c.usePortal;\n      var isOpen = _this.state.isOpen; // compute an appropriate transform origin so the scale animation points towards target\n\n      var transformOrigin = getTransformOrigin(popperProps.placement, _this.isArrowEnabled() ? popperProps.arrowProps.style : undefined); // need to update our reference to this function on every render as it will change.\n\n      _this.popperScheduleUpdate = popperProps.update;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick,\n        // treat ENTER/SPACE keys the same as a click for accessibility\n        // eslint-disable-next-line deprecation/deprecation\n        onKeyDown: function (event) {\n          return Keys.isKeyboardClick(event.keyCode) && _this.handlePopoverClick(event);\n        }\n      };\n\n      if (interactionKind === Popover2InteractionKind.HOVER || !usePortal && interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n\n      var basePlacement = getBasePlacement(popperProps.placement);\n      var popoverClasses = classNames(Classes.POPOVER2, (_a = {}, _a[CoreClasses.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[CoreClasses.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER2_CAPTURING_DISMISS] = _this.props.captureDismiss, _a), Classes.POPOVER2_CONTENT_PLACEMENT + \"-\" + basePlacement, _this.props.popoverClassName);\n      var defaultAutoFocus = _this.isHoverInteractionKind() ? false : undefined;\n      return React.createElement(Overlay, {\n        autoFocus: (_b = _this.props.autoFocus) !== null && _b !== void 0 ? _b : defaultAutoFocus,\n        backdropClassName: Classes.POPOVER2_BACKDROP,\n        backdropProps: _this.props.backdropProps,\n        canEscapeKeyClose: _this.props.canEscapeKeyClose,\n        canOutsideClickClose: _this.props.interactionKind === Popover2InteractionKind.CLICK,\n        enforceFocus: _this.props.enforceFocus,\n        hasBackdrop: _this.props.hasBackdrop,\n        isOpen: isOpen,\n        onClose: _this.handleOverlayClose,\n        onClosed: _this.props.onClosed,\n        onClosing: _this.props.onClosing,\n        onOpened: _this.props.onOpened,\n        onOpening: _this.props.onOpening,\n        transitionDuration: _this.props.transitionDuration,\n        transitionName: Classes.POPOVER2,\n        usePortal: _this.props.usePortal,\n        portalClassName: _this.props.portalClassName,\n        portalContainer: _this.props.portalContainer,\n        // if hover interaciton, it doesn't make sense to take over focus control\n        shouldReturnFocusOnClose: _this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose\n      }, React.createElement(\"div\", {\n        className: Classes.POPOVER2_TRANSITION_CONTAINER,\n        ref: popperProps.ref,\n        style: popperProps.style\n      }, React.createElement(ResizeSensor2, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(Popover2Arrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER2_CONTENT\n      }, _this.props.content)))));\n    };\n\n    _this.handleTargetFocus = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n\n        _this.handleMouseEnter(e);\n      }\n    };\n\n    _this.handleTargetBlur = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        // e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n        // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n        // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n        // close the popover if necessary.\n        if (e.relatedTarget != null) {\n          // if the next element to receive focus is within the popover, we'll want to leave the\n          // popover open.\n          if (e.relatedTarget !== _this.popoverElement && !_this.isElementInPopover(e.relatedTarget)) {\n            _this.handleMouseLeave(e);\n          }\n        }\n      }\n\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n\n    _this.handleTargetContextMenu = function (e) {\n      // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n      // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n      if (e.defaultPrevented) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleMouseEnter = function (e) {\n      _this.isMouseInTargetOrPopover = true; // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n    };\n\n    _this.handleMouseLeave = function (e) {\n      _this.isMouseInTargetOrPopover = false; // wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa).\n\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        } // user-configurable closing delay is helpful when moving mouse from target to popover\n\n\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n    };\n\n    _this.handlePopoverClick = function (e) {\n      var _a, _b, _c, _d;\n\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\" + Classes.POPOVER2);\n      var eventPopoverV1 = eventTarget.closest(\".\" + CoreClasses.POPOVER);\n\n      var isEventFromSelf = (eventPopover !== null && eventPopover !== void 0 ? eventPopover : eventPopoverV1) === _this.getPopoverElement();\n\n      var isEventPopoverCapturing = (_b = (_a = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER2_CAPTURING_DISMISS)) !== null && _a !== void 0 ? _a : eventPopoverV1 === null || eventPopoverV1 === void 0 ? void 0 : eventPopoverV1.classList.contains(CoreClasses.POPOVER_CAPTURING_DISMISS)) !== null && _b !== void 0 ? _b : false; // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n\n      var dismissElement = eventTarget.closest(\".\" + Classes.POPOVER2_DISMISS + \", .\" + Classes.POPOVER2_DISMISS_OVERRIDE); // dismiss selectors from the \"V1\" version of Popover in the core pacakge\n      // we expect these to be rendered by MenuItem, which at this point has no knowledge of Popover2\n      // this can be removed once Popover2 is merged into core in v5.0\n\n      var dismissElementV1 = eventTarget.closest(\".\" + CoreClasses.POPOVER_DISMISS + \", .\" + CoreClasses.POPOVER_DISMISS_OVERRIDE);\n      var shouldDismiss = (_d = (_c = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(Classes.POPOVER2_DISMISS)) !== null && _c !== void 0 ? _c : dismissElementV1 === null || dismissElementV1 === void 0 ? void 0 : dismissElementV1.classList.contains(CoreClasses.POPOVER_DISMISS)) !== null && _d !== void 0 ? _d : false;\n      var isDisabled = eventTarget.closest(\":disabled, .\" + CoreClasses.DISABLED) != null;\n\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleOverlayClose = function (e) {\n      if (_this.targetElement === null || e === undefined) {\n        return;\n      }\n\n      var eventTarget = e.target; // if click was in target, target event listener will handle things, so don't close\n\n      if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleTargetClick = function (e) {\n      // ensure click did not originate from within inline popover before closing\n      if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n        if (_this.props.isOpen == null) {\n          _this.setState(function (prevState) {\n            return {\n              isOpen: !prevState.isOpen\n            };\n          });\n        } else {\n          _this.setOpenState(!_this.props.isOpen, e);\n        }\n      }\n    };\n\n    return _this;\n  } // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n  // so if we want to look at our actual popover element, we need to reach inside a bit\n\n\n  Popover2.prototype.getPopoverElement = function () {\n    var _a;\n\n    return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.querySelector(\".\" + Classes.POPOVER2);\n  };\n\n  Popover2.prototype.getIsOpen = function (props) {\n    var _a; // disabled popovers should never be allowed to open.\n\n\n    if (props.disabled) {\n      return false;\n    } else {\n      return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;\n    }\n  };\n\n  Popover2.prototype.render = function () {\n    var _a = this.props,\n        disabled = _a.disabled,\n        content = _a.content,\n        placement = _a.placement,\n        _b = _a.position,\n        position = _b === void 0 ? \"auto\" : _b,\n        positioningStrategy = _a.positioningStrategy;\n    var isOpen = this.state.isOpen;\n    var isContentEmpty = content == null || typeof content === \"string\" && content.trim() === \"\";\n\n    if (isContentEmpty) {\n      // need to do this check in render(), because `isOpen` is derived from\n      // state, and state can't necessarily be accessed in validateProps.\n      if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n        console.warn(Errors.POPOVER2_WARN_EMPTY_CONTENT);\n      } // just render the target without a content overlay if there is no content to display\n\n\n      return this.renderTarget({\n        ref: noop\n      });\n    }\n\n    return React.createElement(Manager, null, React.createElement(Reference, null, this.renderTarget), React.createElement(Popper, {\n      innerRef: this.popoverRef,\n      placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position),\n      strategy: positioningStrategy,\n      modifiers: this.getPopperModifiers()\n    }, this.renderPopover));\n  };\n\n  Popover2.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n\n  Popover2.prototype.componentDidUpdate = function (props, state) {\n    _super.prototype.componentDidUpdate.call(this, props, state);\n\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen); // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n\n  Popover2.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER2_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER2_WARN_HAS_BACKDROP_INLINE);\n    }\n\n    if (props.hasBackdrop && props.interactionKind !== Popover2InteractionKind.CLICK) {\n      console.warn(Errors.POPOVER2_HAS_BACKDROP_INTERACTION);\n    }\n\n    if (props.placement !== undefined && props.position !== undefined) {\n      console.warn(Errors.POPOVER2_WARN_PLACEMENT_AND_POSITION_MUTEX);\n    }\n\n    var childrenCount = React.Children.count(props.children);\n    var hasRenderTargetPropp = props.renderTarget !== undefined;\n\n    if (childrenCount === 0 && !hasRenderTargetPropp) {\n      console.warn(Errors.POPOVER2_REQUIRES_TARGET);\n    }\n\n    if (childrenCount > 1) {\n      console.warn(Errors.POPOVER2_WARN_TOO_MANY_CHILDREN);\n    }\n\n    if (childrenCount > 0 && hasRenderTargetPropp) {\n      console.warn(Errors.POPOVER2_WARN_DOUBLE_TARGET);\n    }\n  };\n\n  Popover2.prototype.getPopperModifiers = function () {\n    var _a, _b, _c, _d;\n\n    var modifiers = this.props.modifiers;\n    return [__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"arrow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow), __assign(__assign({\n      name: \"computeStyles\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles), {\n      options: __assign({\n        adaptive: true,\n        // We disable the built-in gpuAcceleration so that\n        // Popper.js will return us easy to interpolate values\n        // (top, left instead of transform: translate3d)\n        // We'll then use these values to generate the needed\n        // css transform values blended with the react-spring values\n        gpuAcceleration: false\n      }, (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options)\n    }), __assign(__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"offset\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset), {\n      options: __assign({\n        offset: [0, POPOVER_ARROW_SVG_SIZE / 2]\n      }, (_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options)\n    }), __assign(__assign({\n      name: \"flip\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options)\n    }), __assign(__assign({\n      name: \"preventOverflow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options)\n    })];\n  }; // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n\n\n  Popover2.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n\n    var _a, _b, _c, _d, _e; // cancel any existing timeout because we have new state\n\n\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (timeout !== undefined && timeout > 0) {\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        return _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n      }\n    }\n  };\n\n  Popover2.prototype.updateDarkParent = function () {\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\" + CoreClasses.DARK) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  };\n\n  Popover2.prototype.isElementInPopover = function (element) {\n    var _a, _b;\n\n    return (_b = (_a = this.getPopoverElement()) === null || _a === void 0 ? void 0 : _a.contains(element)) !== null && _b !== void 0 ? _b : false;\n  };\n\n  Popover2.displayName = DISPLAYNAME_PREFIX + \".Popover2\";\n  Popover2.defaultProps = {\n    boundary: \"clippingParents\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: Popover2InteractionKind.CLICK,\n    minimal: false,\n    openOnTargetFocus: true,\n    // N.B. we don't set a default for `placement` or `position` here because that would trigger\n    // a warning in validateProps if the other prop is specified by a user of this component\n    positioningStrategy: \"absolute\",\n    renderTarget: undefined,\n    shouldReturnFocusOnClose: false,\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true\n  };\n  return Popover2;\n}(AbstractPureComponent2);\n\nexport { Popover2 };\n\nfunction noop() {} // no-op","map":{"version":3,"sources":["../../src/popover2.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes as CoreClasses, DISPLAYNAME_PREFIX, Keys, refHandler, mergeRefs, Overlay, Utils, } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport * as Errors from \"./errors\";\nimport { POPOVER_ARROW_SVG_SIZE, Popover2Arrow } from \"./popover2Arrow\";\nimport { positionToPlacement } from \"./popover2PlacementUtils\";\nimport { ResizeSensor2 } from \"./resizeSensor2\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip2 } from \"./tooltip2\";\nimport { getBasePlacement, getTransformOrigin } from \"./utils\";\nexport var Popover2InteractionKind = {\n    CLICK: \"click\",\n    CLICK_TARGET_ONLY: \"click-target\",\n    HOVER: \"hover\",\n    HOVER_TARGET_ONLY: \"hover-target\",\n};\n/**\n * @template T target component props inteface\n */\nvar Popover2 = /** @class */ (function (_super) {\n    __extends(Popover2, _super);\n    function Popover2() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            hasDarkParent: false,\n            isOpen: _this.getIsOpen(_this.props),\n        };\n        /**\n         * DOM element that contains the popover.\n         * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n         * so this reference can be very useful for testing.\n         */\n        _this.popoverElement = null;\n        /** DOM element that contains the target. */\n        _this.targetElement = null;\n        /** Popover ref handler */\n        _this.popoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n        /** Target ref handler */\n        _this.targetRef = function (el) { return (_this.targetElement = el); };\n        // a flag that lets us detect mouse movement between the target and popover,\n        // now that mouseleave is triggered when you cross the gap between the two.\n        _this.isMouseInTargetOrPopover = false;\n        // a flag that indicates whether the target previously lost focus to another\n        // element on the same page.\n        _this.lostFocusOnSamePage = true;\n        _this.isControlled = function () { return _this.props.isOpen !== undefined; };\n        // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n        _this.isArrowEnabled = function () { var _a, _b; return !_this.props.minimal && ((_b = (_a = _this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false; };\n        _this.isHoverInteractionKind = function () {\n            return (_this.props.interactionKind === Popover2InteractionKind.HOVER ||\n                _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY);\n        };\n        /**\n         * Instance method to instruct the `Popover` to recompute its position.\n         *\n         * This method should only be used if you are updating the target in a way\n         * that does not cause it to re-render, such as changing its _position_\n         * without changing its _size_ (since `Popover` already repositions when it\n         * detects a resize).\n         */\n        _this.reposition = function () { var _a; return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this); };\n        _this.renderTarget = function (_a) {\n            var _b, _c;\n            var _d;\n            var popperChildRef = _a.ref;\n            var _e = _this.props, children = _e.children, className = _e.className, fill = _e.fill, openOnTargetFocus = _e.openOnTargetFocus, renderTarget = _e.renderTarget;\n            var isOpen = _this.state.isOpen;\n            var isControlled = _this.isControlled();\n            var isHoverInteractionKind = _this.isHoverInteractionKind();\n            var targetTagName = _this.props.targetTagName;\n            if (fill) {\n                targetTagName = \"div\";\n            }\n            var ref = mergeRefs(popperChildRef, _this.targetRef);\n            var targetEventHandlers = isHoverInteractionKind\n                ? {\n                    // HOVER handlers\n                    onBlur: _this.handleTargetBlur,\n                    onContextMenu: _this.handleTargetContextMenu,\n                    onFocus: _this.handleTargetFocus,\n                    onMouseEnter: _this.handleMouseEnter,\n                    onMouseLeave: _this.handleMouseLeave,\n                }\n                : {\n                    // CLICK needs only one handler\n                    onClick: _this.handleTargetClick,\n                    // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n                    onKeyDown: function (event) {\n                        // eslint-disable-next-line deprecation/deprecation\n                        return Keys.isKeyboardClick(event.keyCode) && _this.handleTargetClick(event);\n                    },\n                };\n            // Ensure target is focusable if relevant prop enabled\n            var targetTabIndex = openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n            var targetProps = __assign({ \"aria-haspopup\": \"true\", \n                // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n                // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n                // applied to the generated target wrapper element.\n                className: classNames(className, Classes.POPOVER2_TARGET, (_b = {},\n                    _b[Classes.POPOVER2_OPEN] = isOpen,\n                    // this class is mainly useful for button targets\n                    _b[CoreClasses.ACTIVE] = !isControlled && isOpen && !isHoverInteractionKind,\n                    _b)), ref: ref }, targetEventHandlers);\n            var target;\n            if (renderTarget !== undefined) {\n                target = renderTarget(__assign(__assign({}, targetProps), { \n                    // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n                    // when *this* popover is open\n                    isOpen: isOpen, tabIndex: targetTabIndex }));\n            }\n            else {\n                var childTarget = Utils.ensureElement(React.Children.toArray(children)[0]);\n                if (childTarget === undefined) {\n                    return null;\n                }\n                var targetModifierClasses = (_c = {},\n                    // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n                    // uncontrolled popovers when they are opened by a user interaction\n                    _c[CoreClasses.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind,\n                    // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n                    _c[CoreClasses.FILL] = fill,\n                    _c);\n                var clonedTarget = React.cloneElement(childTarget, {\n                    className: classNames(childTarget.props.className, targetModifierClasses),\n                    // force disable single Tooltip2 child when popover is open\n                    disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip2) ? true : childTarget.props.disabled,\n                    tabIndex: (_d = childTarget.props.tabIndex) !== null && _d !== void 0 ? _d : targetTabIndex,\n                });\n                var wrappedTarget = React.createElement(targetTagName, targetProps, clonedTarget);\n                target = wrappedTarget;\n            }\n            return (React.createElement(ResizeSensor2, { targetRef: ref, onResize: _this.reposition }, target));\n        };\n        _this.renderPopover = function (popperProps) {\n            var _a;\n            var _b;\n            var _c = _this.props, interactionKind = _c.interactionKind, shouldReturnFocusOnClose = _c.shouldReturnFocusOnClose, usePortal = _c.usePortal;\n            var isOpen = _this.state.isOpen;\n            // compute an appropriate transform origin so the scale animation points towards target\n            var transformOrigin = getTransformOrigin(popperProps.placement, _this.isArrowEnabled() ? popperProps.arrowProps.style : undefined);\n            // need to update our reference to this function on every render as it will change.\n            _this.popperScheduleUpdate = popperProps.update;\n            var popoverHandlers = {\n                // always check popover clicks for dismiss class\n                onClick: _this.handlePopoverClick,\n                // treat ENTER/SPACE keys the same as a click for accessibility\n                // eslint-disable-next-line deprecation/deprecation\n                onKeyDown: function (event) { return Keys.isKeyboardClick(event.keyCode) && _this.handlePopoverClick(event); },\n            };\n            if (interactionKind === Popover2InteractionKind.HOVER ||\n                (!usePortal && interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY)) {\n                popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n                popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n            }\n            var basePlacement = getBasePlacement(popperProps.placement);\n            var popoverClasses = classNames(Classes.POPOVER2, (_a = {},\n                _a[CoreClasses.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent,\n                _a[CoreClasses.MINIMAL] = _this.props.minimal,\n                _a[Classes.POPOVER2_CAPTURING_DISMISS] = _this.props.captureDismiss,\n                _a), Classes.POPOVER2_CONTENT_PLACEMENT + \"-\" + basePlacement, _this.props.popoverClassName);\n            var defaultAutoFocus = _this.isHoverInteractionKind() ? false : undefined;\n            return (React.createElement(Overlay, { autoFocus: (_b = _this.props.autoFocus) !== null && _b !== void 0 ? _b : defaultAutoFocus, backdropClassName: Classes.POPOVER2_BACKDROP, backdropProps: _this.props.backdropProps, canEscapeKeyClose: _this.props.canEscapeKeyClose, canOutsideClickClose: _this.props.interactionKind === Popover2InteractionKind.CLICK, enforceFocus: _this.props.enforceFocus, hasBackdrop: _this.props.hasBackdrop, isOpen: isOpen, onClose: _this.handleOverlayClose, onClosed: _this.props.onClosed, onClosing: _this.props.onClosing, onOpened: _this.props.onOpened, onOpening: _this.props.onOpening, transitionDuration: _this.props.transitionDuration, transitionName: Classes.POPOVER2, usePortal: _this.props.usePortal, portalClassName: _this.props.portalClassName, portalContainer: _this.props.portalContainer, \n                // if hover interaciton, it doesn't make sense to take over focus control\n                shouldReturnFocusOnClose: _this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose },\n                React.createElement(\"div\", { className: Classes.POPOVER2_TRANSITION_CONTAINER, ref: popperProps.ref, style: popperProps.style },\n                    React.createElement(ResizeSensor2, { onResize: _this.reposition },\n                        React.createElement(\"div\", __assign({ className: popoverClasses, style: { transformOrigin: transformOrigin }, ref: _this.popoverRef }, popoverHandlers),\n                            _this.isArrowEnabled() && (React.createElement(Popover2Arrow, { arrowProps: popperProps.arrowProps, placement: popperProps.placement })),\n                            React.createElement(\"div\", { className: Classes.POPOVER2_CONTENT }, _this.props.content))))));\n        };\n        _this.handleTargetFocus = function (e) {\n            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n                if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n                    // ignore this focus event -- the target was already focused but the page itself\n                    // lost focus (e.g. due to switching tabs).\n                    return;\n                }\n                _this.handleMouseEnter(e);\n            }\n        };\n        _this.handleTargetBlur = function (e) {\n            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n                // e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n                // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n                // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n                // close the popover if necessary.\n                if (e.relatedTarget != null) {\n                    // if the next element to receive focus is within the popover, we'll want to leave the\n                    // popover open.\n                    if (e.relatedTarget !== _this.popoverElement &&\n                        !_this.isElementInPopover(e.relatedTarget)) {\n                        _this.handleMouseLeave(e);\n                    }\n                }\n            }\n            _this.lostFocusOnSamePage = e.relatedTarget != null;\n        };\n        _this.handleTargetContextMenu = function (e) {\n            // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n            // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n            if (e.defaultPrevented) {\n                _this.setOpenState(false, e);\n            }\n        };\n        _this.handleMouseEnter = function (e) {\n            _this.isMouseInTargetOrPopover = true;\n            // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n            // trigger the mouse leave event, as hovering over the popover shouldn't count.\n            if (!_this.props.usePortal &&\n                _this.isElementInPopover(e.target) &&\n                _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY &&\n                !_this.props.openOnTargetFocus) {\n                _this.handleMouseLeave(e);\n            }\n            else if (!_this.props.disabled) {\n                // only begin opening popover when it is enabled\n                _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n            }\n        };\n        _this.handleMouseLeave = function (e) {\n            _this.isMouseInTargetOrPopover = false;\n            // wait until the event queue is flushed, because we want to leave the\n            // popover open if the mouse entered the popover immediately after\n            // leaving the target (or vice versa).\n            _this.setTimeout(function () {\n                if (_this.isMouseInTargetOrPopover) {\n                    return;\n                }\n                // user-configurable closing delay is helpful when moving mouse from target to popover\n                _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n            });\n        };\n        _this.handlePopoverClick = function (e) {\n            var _a, _b, _c, _d;\n            var eventTarget = e.target;\n            var eventPopover = eventTarget.closest(\".\" + Classes.POPOVER2);\n            var eventPopoverV1 = eventTarget.closest(\".\" + CoreClasses.POPOVER);\n            var isEventFromSelf = (eventPopover !== null && eventPopover !== void 0 ? eventPopover : eventPopoverV1) === _this.getPopoverElement();\n            var isEventPopoverCapturing = (_b = (_a = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER2_CAPTURING_DISMISS)) !== null && _a !== void 0 ? _a : eventPopoverV1 === null || eventPopoverV1 === void 0 ? void 0 : eventPopoverV1.classList.contains(CoreClasses.POPOVER_CAPTURING_DISMISS)) !== null && _b !== void 0 ? _b : false;\n            // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n            var dismissElement = eventTarget.closest(\".\" + Classes.POPOVER2_DISMISS + \", .\" + Classes.POPOVER2_DISMISS_OVERRIDE);\n            // dismiss selectors from the \"V1\" version of Popover in the core pacakge\n            // we expect these to be rendered by MenuItem, which at this point has no knowledge of Popover2\n            // this can be removed once Popover2 is merged into core in v5.0\n            var dismissElementV1 = eventTarget.closest(\".\" + CoreClasses.POPOVER_DISMISS + \", .\" + CoreClasses.POPOVER_DISMISS_OVERRIDE);\n            var shouldDismiss = (_d = (_c = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(Classes.POPOVER2_DISMISS)) !== null && _c !== void 0 ? _c : dismissElementV1 === null || dismissElementV1 === void 0 ? void 0 : dismissElementV1.classList.contains(CoreClasses.POPOVER_DISMISS)) !== null && _d !== void 0 ? _d : false;\n            var isDisabled = eventTarget.closest(\":disabled, .\" + CoreClasses.DISABLED) != null;\n            if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n                _this.setOpenState(false, e);\n            }\n        };\n        _this.handleOverlayClose = function (e) {\n            if (_this.targetElement === null || e === undefined) {\n                return;\n            }\n            var eventTarget = e.target;\n            // if click was in target, target event listener will handle things, so don't close\n            if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n                _this.setOpenState(false, e);\n            }\n        };\n        _this.handleTargetClick = function (e) {\n            // ensure click did not originate from within inline popover before closing\n            if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n                if (_this.props.isOpen == null) {\n                    _this.setState(function (prevState) { return ({ isOpen: !prevState.isOpen }); });\n                }\n                else {\n                    _this.setOpenState(!_this.props.isOpen, e);\n                }\n            }\n        };\n        return _this;\n    }\n    // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n    // so if we want to look at our actual popover element, we need to reach inside a bit\n    Popover2.prototype.getPopoverElement = function () {\n        var _a;\n        return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.querySelector(\".\" + Classes.POPOVER2);\n    };\n    Popover2.prototype.getIsOpen = function (props) {\n        var _a;\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        }\n        else {\n            return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;\n        }\n    };\n    Popover2.prototype.render = function () {\n        var _a = this.props, disabled = _a.disabled, content = _a.content, placement = _a.placement, _b = _a.position, position = _b === void 0 ? \"auto\" : _b, positioningStrategy = _a.positioningStrategy;\n        var isOpen = this.state.isOpen;\n        var isContentEmpty = content == null || (typeof content === \"string\" && content.trim() === \"\");\n        if (isContentEmpty) {\n            // need to do this check in render(), because `isOpen` is derived from\n            // state, and state can't necessarily be accessed in validateProps.\n            if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n                console.warn(Errors.POPOVER2_WARN_EMPTY_CONTENT);\n            }\n            // just render the target without a content overlay if there is no content to display\n            return this.renderTarget({ ref: noop });\n        }\n        return (React.createElement(Manager, null,\n            React.createElement(Reference, null, this.renderTarget),\n            React.createElement(Popper, { innerRef: this.popoverRef, placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position), strategy: positioningStrategy, modifiers: this.getPopperModifiers() }, this.renderPopover)));\n    };\n    Popover2.prototype.componentDidMount = function () {\n        this.updateDarkParent();\n    };\n    Popover2.prototype.componentDidUpdate = function (props, state) {\n        _super.prototype.componentDidUpdate.call(this, props, state);\n        this.updateDarkParent();\n        var nextIsOpen = this.getIsOpen(this.props);\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        }\n        else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    };\n    Popover2.prototype.validateProps = function (props) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER2_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER2_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== Popover2InteractionKind.CLICK) {\n            console.warn(Errors.POPOVER2_HAS_BACKDROP_INTERACTION);\n        }\n        if (props.placement !== undefined && props.position !== undefined) {\n            console.warn(Errors.POPOVER2_WARN_PLACEMENT_AND_POSITION_MUTEX);\n        }\n        var childrenCount = React.Children.count(props.children);\n        var hasRenderTargetPropp = props.renderTarget !== undefined;\n        if (childrenCount === 0 && !hasRenderTargetPropp) {\n            console.warn(Errors.POPOVER2_REQUIRES_TARGET);\n        }\n        if (childrenCount > 1) {\n            console.warn(Errors.POPOVER2_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasRenderTargetPropp) {\n            console.warn(Errors.POPOVER2_WARN_DOUBLE_TARGET);\n        }\n    };\n    Popover2.prototype.getPopperModifiers = function () {\n        var _a, _b, _c, _d;\n        var modifiers = this.props.modifiers;\n        return [\n            __assign({ enabled: this.isArrowEnabled(), name: \"arrow\" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow),\n            __assign(__assign({ name: \"computeStyles\" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles), { options: __assign({ adaptive: true, \n                    // We disable the built-in gpuAcceleration so that\n                    // Popper.js will return us easy to interpolate values\n                    // (top, left instead of transform: translate3d)\n                    // We'll then use these values to generate the needed\n                    // css transform values blended with the react-spring values\n                    gpuAcceleration: false }, (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options) }),\n            __assign(__assign({ enabled: this.isArrowEnabled(), name: \"offset\" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset), { options: __assign({ offset: [0, POPOVER_ARROW_SVG_SIZE / 2] }, (_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options) }),\n            __assign(__assign({ name: \"flip\" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip), { options: __assign({ boundary: this.props.boundary, rootBoundary: this.props.rootBoundary }, (_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options) }),\n            __assign(__assign({ name: \"preventOverflow\" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow), { options: __assign({ boundary: this.props.boundary, rootBoundary: this.props.rootBoundary }, (_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options) }),\n        ];\n    };\n    // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    Popover2.prototype.setOpenState = function (isOpen, e, timeout) {\n        var _this = this;\n        var _a, _b, _c, _d, _e;\n        // cancel any existing timeout because we have new state\n        (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n        if (timeout !== undefined && timeout > 0) {\n            this.cancelOpenTimeout = this.setTimeout(function () { return _this.setOpenState(isOpen, e); }, timeout);\n        }\n        else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen: isOpen });\n            }\n            else {\n                (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n            }\n        }\n    };\n    Popover2.prototype.updateDarkParent = function () {\n        if (this.props.usePortal && this.state.isOpen) {\n            var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\" + CoreClasses.DARK) != null;\n            this.setState({ hasDarkParent: hasDarkParent });\n        }\n    };\n    Popover2.prototype.isElementInPopover = function (element) {\n        var _a, _b;\n        return (_b = (_a = this.getPopoverElement()) === null || _a === void 0 ? void 0 : _a.contains(element)) !== null && _b !== void 0 ? _b : false;\n    };\n    Popover2.displayName = DISPLAYNAME_PREFIX + \".Popover2\";\n    Popover2.defaultProps = {\n        boundary: \"clippingParents\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: Popover2InteractionKind.CLICK,\n        minimal: false,\n        openOnTargetFocus: true,\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\n        // a warning in validateProps if the other prop is specified by a user of this component\n        positioningStrategy: \"absolute\",\n        renderTarget: undefined,\n        shouldReturnFocusOnClose: false,\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n    };\n    return Popover2;\n}(AbstractPureComponent2));\nexport { Popover2 };\nfunction noop() {\n    // no-op\n}\n//# sourceMappingURL=popover2.js.map"]},"metadata":{},"sourceType":"module"}