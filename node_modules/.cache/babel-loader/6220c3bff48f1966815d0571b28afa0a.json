{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Boundary } from \"@blueprintjs/core\";\nimport { areSameDay } from \"./common/dateUtils\";\n\nvar DateRangeSelectionStrategy =\n/** @class */\nfunction () {\n  function DateRangeSelectionStrategy() {}\n  /**\n   * Returns the new date-range and the boundary that would be affected if `day` were clicked. The\n   * affected boundary may be different from the provided `boundary` in some cases. For example,\n   * clicking a particular boundary's selected date will always deselect it regardless of which\n   * `boundary` you provide to this function (because it's simply a more intuitive interaction).\n   */\n\n\n  DateRangeSelectionStrategy.getNextState = function (currentRange, day, allowSingleDayRange, boundary) {\n    if (boundary != null) {\n      return this.getNextStateForBoundary(currentRange, day, allowSingleDayRange, boundary);\n    } else {\n      return this.getDefaultNextState(currentRange, day, allowSingleDayRange);\n    }\n  };\n\n  DateRangeSelectionStrategy.getNextStateForBoundary = function (currentRange, day, allowSingleDayRange, boundary) {\n    var boundaryDate = this.getBoundaryDate(boundary, currentRange);\n    var otherBoundary = this.getOtherBoundary(boundary);\n    var otherBoundaryDate = this.getBoundaryDate(otherBoundary, currentRange);\n    var nextBoundary;\n    var nextDateRange;\n\n    if (boundaryDate == null && otherBoundaryDate == null) {\n      nextBoundary = boundary;\n      nextDateRange = this.createRangeForBoundary(boundary, day, null);\n    } else if (boundaryDate != null && otherBoundaryDate == null) {\n      var nextBoundaryDate = areSameDay(boundaryDate, day) ? null : day;\n      nextBoundary = boundary;\n      nextDateRange = this.createRangeForBoundary(boundary, nextBoundaryDate, null);\n    } else if (boundaryDate == null && otherBoundaryDate != null) {\n      if (areSameDay(day, otherBoundaryDate)) {\n        var nextDate = void 0;\n\n        if (allowSingleDayRange) {\n          nextBoundary = boundary;\n          nextDate = otherBoundaryDate;\n        } else {\n          nextBoundary = otherBoundary;\n          nextDate = null;\n        }\n\n        nextDateRange = this.createRangeForBoundary(boundary, nextDate, nextDate);\n      } else if (this.isOverlappingOtherBoundary(boundary, day, otherBoundaryDate)) {\n        nextBoundary = otherBoundary;\n        nextDateRange = this.createRangeForBoundary(boundary, otherBoundaryDate, day);\n      } else {\n        nextBoundary = boundary;\n        nextDateRange = this.createRangeForBoundary(boundary, day, otherBoundaryDate);\n      }\n    } else {\n      // both boundaryDate and otherBoundaryDate are already defined\n      if (areSameDay(boundaryDate, day)) {\n        var isSingleDayRangeSelected = areSameDay(boundaryDate, otherBoundaryDate);\n        var nextOtherBoundaryDate = isSingleDayRangeSelected ? null : otherBoundaryDate;\n        nextBoundary = boundary;\n        nextDateRange = this.createRangeForBoundary(boundary, null, nextOtherBoundaryDate);\n      } else if (areSameDay(day, otherBoundaryDate)) {\n        var _a = allowSingleDayRange ? [otherBoundaryDate, otherBoundaryDate] : [boundaryDate, null],\n            nextBoundaryDate = _a[0],\n            nextOtherBoundaryDate = _a[1];\n\n        nextBoundary = allowSingleDayRange ? boundary : otherBoundary;\n        nextDateRange = this.createRangeForBoundary(boundary, nextBoundaryDate, nextOtherBoundaryDate);\n      } else if (this.isOverlappingOtherBoundary(boundary, day, otherBoundaryDate)) {\n        nextBoundary = boundary;\n        nextDateRange = this.createRangeForBoundary(boundary, day, null);\n      } else {\n        // extend the date range with an earlier boundaryDate date\n        nextBoundary = boundary;\n        nextDateRange = this.createRangeForBoundary(boundary, day, otherBoundaryDate);\n      }\n    }\n\n    return {\n      dateRange: nextDateRange,\n      boundary: nextBoundary\n    };\n  };\n\n  DateRangeSelectionStrategy.getDefaultNextState = function (selectedRange, day, allowSingleDayRange) {\n    var start = selectedRange[0],\n        end = selectedRange[1];\n    var nextDateRange;\n\n    if (start == null && end == null) {\n      nextDateRange = [day, null];\n    } else if (start != null && end == null) {\n      nextDateRange = this.createRange(day, start, allowSingleDayRange);\n    } else if (start == null && end != null) {\n      nextDateRange = this.createRange(day, end, allowSingleDayRange);\n    } else {\n      var isStart = areSameDay(start, day);\n      var isEnd = areSameDay(end, day);\n\n      if (isStart && isEnd) {\n        nextDateRange = [null, null];\n      } else if (isStart) {\n        nextDateRange = [null, end];\n      } else if (isEnd) {\n        nextDateRange = [start, null];\n      } else {\n        nextDateRange = [day, null];\n      }\n    }\n\n    return {\n      dateRange: nextDateRange\n    };\n  };\n\n  DateRangeSelectionStrategy.getOtherBoundary = function (boundary) {\n    return boundary === Boundary.START ? Boundary.END : Boundary.START;\n  };\n\n  DateRangeSelectionStrategy.getBoundaryDate = function (boundary, dateRange) {\n    return boundary === Boundary.START ? dateRange[0] : dateRange[1];\n  };\n\n  DateRangeSelectionStrategy.isOverlappingOtherBoundary = function (boundary, boundaryDate, otherBoundaryDate) {\n    return boundary === Boundary.START ? boundaryDate > otherBoundaryDate : boundaryDate < otherBoundaryDate;\n  };\n\n  DateRangeSelectionStrategy.createRangeForBoundary = function (boundary, boundaryDate, otherBoundaryDate) {\n    return boundary === Boundary.START ? [boundaryDate, otherBoundaryDate] : [otherBoundaryDate, boundaryDate];\n  };\n\n  DateRangeSelectionStrategy.createRange = function (a, b, allowSingleDayRange) {\n    // clicking the same date again will clear it\n    if (!allowSingleDayRange && areSameDay(a, b)) {\n      return [null, null];\n    }\n\n    return a < b ? [a, b] : [b, a];\n  };\n\n  return DateRangeSelectionStrategy;\n}();\n\nexport { DateRangeSelectionStrategy };","map":{"version":3,"sources":["../../src/dateRangeSelectionStrategy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Boundary } from \"@blueprintjs/core\";\nimport { areSameDay } from \"./common/dateUtils\";\nvar DateRangeSelectionStrategy = /** @class */ (function () {\n    function DateRangeSelectionStrategy() {\n    }\n    /**\n     * Returns the new date-range and the boundary that would be affected if `day` were clicked. The\n     * affected boundary may be different from the provided `boundary` in some cases. For example,\n     * clicking a particular boundary's selected date will always deselect it regardless of which\n     * `boundary` you provide to this function (because it's simply a more intuitive interaction).\n     */\n    DateRangeSelectionStrategy.getNextState = function (currentRange, day, allowSingleDayRange, boundary) {\n        if (boundary != null) {\n            return this.getNextStateForBoundary(currentRange, day, allowSingleDayRange, boundary);\n        }\n        else {\n            return this.getDefaultNextState(currentRange, day, allowSingleDayRange);\n        }\n    };\n    DateRangeSelectionStrategy.getNextStateForBoundary = function (currentRange, day, allowSingleDayRange, boundary) {\n        var boundaryDate = this.getBoundaryDate(boundary, currentRange);\n        var otherBoundary = this.getOtherBoundary(boundary);\n        var otherBoundaryDate = this.getBoundaryDate(otherBoundary, currentRange);\n        var nextBoundary;\n        var nextDateRange;\n        if (boundaryDate == null && otherBoundaryDate == null) {\n            nextBoundary = boundary;\n            nextDateRange = this.createRangeForBoundary(boundary, day, null);\n        }\n        else if (boundaryDate != null && otherBoundaryDate == null) {\n            var nextBoundaryDate = areSameDay(boundaryDate, day) ? null : day;\n            nextBoundary = boundary;\n            nextDateRange = this.createRangeForBoundary(boundary, nextBoundaryDate, null);\n        }\n        else if (boundaryDate == null && otherBoundaryDate != null) {\n            if (areSameDay(day, otherBoundaryDate)) {\n                var nextDate = void 0;\n                if (allowSingleDayRange) {\n                    nextBoundary = boundary;\n                    nextDate = otherBoundaryDate;\n                }\n                else {\n                    nextBoundary = otherBoundary;\n                    nextDate = null;\n                }\n                nextDateRange = this.createRangeForBoundary(boundary, nextDate, nextDate);\n            }\n            else if (this.isOverlappingOtherBoundary(boundary, day, otherBoundaryDate)) {\n                nextBoundary = otherBoundary;\n                nextDateRange = this.createRangeForBoundary(boundary, otherBoundaryDate, day);\n            }\n            else {\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, day, otherBoundaryDate);\n            }\n        }\n        else {\n            // both boundaryDate and otherBoundaryDate are already defined\n            if (areSameDay(boundaryDate, day)) {\n                var isSingleDayRangeSelected = areSameDay(boundaryDate, otherBoundaryDate);\n                var nextOtherBoundaryDate = isSingleDayRangeSelected ? null : otherBoundaryDate;\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, null, nextOtherBoundaryDate);\n            }\n            else if (areSameDay(day, otherBoundaryDate)) {\n                var _a = allowSingleDayRange\n                    ? [otherBoundaryDate, otherBoundaryDate]\n                    : [boundaryDate, null], nextBoundaryDate = _a[0], nextOtherBoundaryDate = _a[1];\n                nextBoundary = allowSingleDayRange ? boundary : otherBoundary;\n                nextDateRange = this.createRangeForBoundary(boundary, nextBoundaryDate, nextOtherBoundaryDate);\n            }\n            else if (this.isOverlappingOtherBoundary(boundary, day, otherBoundaryDate)) {\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, day, null);\n            }\n            else {\n                // extend the date range with an earlier boundaryDate date\n                nextBoundary = boundary;\n                nextDateRange = this.createRangeForBoundary(boundary, day, otherBoundaryDate);\n            }\n        }\n        return { dateRange: nextDateRange, boundary: nextBoundary };\n    };\n    DateRangeSelectionStrategy.getDefaultNextState = function (selectedRange, day, allowSingleDayRange) {\n        var start = selectedRange[0], end = selectedRange[1];\n        var nextDateRange;\n        if (start == null && end == null) {\n            nextDateRange = [day, null];\n        }\n        else if (start != null && end == null) {\n            nextDateRange = this.createRange(day, start, allowSingleDayRange);\n        }\n        else if (start == null && end != null) {\n            nextDateRange = this.createRange(day, end, allowSingleDayRange);\n        }\n        else {\n            var isStart = areSameDay(start, day);\n            var isEnd = areSameDay(end, day);\n            if (isStart && isEnd) {\n                nextDateRange = [null, null];\n            }\n            else if (isStart) {\n                nextDateRange = [null, end];\n            }\n            else if (isEnd) {\n                nextDateRange = [start, null];\n            }\n            else {\n                nextDateRange = [day, null];\n            }\n        }\n        return { dateRange: nextDateRange };\n    };\n    DateRangeSelectionStrategy.getOtherBoundary = function (boundary) {\n        return boundary === Boundary.START ? Boundary.END : Boundary.START;\n    };\n    DateRangeSelectionStrategy.getBoundaryDate = function (boundary, dateRange) {\n        return boundary === Boundary.START ? dateRange[0] : dateRange[1];\n    };\n    DateRangeSelectionStrategy.isOverlappingOtherBoundary = function (boundary, boundaryDate, otherBoundaryDate) {\n        return boundary === Boundary.START ? boundaryDate > otherBoundaryDate : boundaryDate < otherBoundaryDate;\n    };\n    DateRangeSelectionStrategy.createRangeForBoundary = function (boundary, boundaryDate, otherBoundaryDate) {\n        return boundary === Boundary.START\n            ? [boundaryDate, otherBoundaryDate]\n            : [otherBoundaryDate, boundaryDate];\n    };\n    DateRangeSelectionStrategy.createRange = function (a, b, allowSingleDayRange) {\n        // clicking the same date again will clear it\n        if (!allowSingleDayRange && areSameDay(a, b)) {\n            return [null, null];\n        }\n        return a < b ? [a, b] : [b, a];\n    };\n    return DateRangeSelectionStrategy;\n}());\nexport { DateRangeSelectionStrategy };\n//# sourceMappingURL=dateRangeSelectionStrategy.js.map"]},"metadata":{},"sourceType":"module"}